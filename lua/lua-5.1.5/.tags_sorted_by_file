!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_PROGRAM_VERSION	5.8	//
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
INSTALL	Makefile	/^INSTALL= install -p$/;"	m
INSTALL_BIN	Makefile	/^INSTALL_BIN= $(INSTALL_TOP)\/bin$/;"	m
INSTALL_CMOD	Makefile	/^INSTALL_CMOD= $(INSTALL_TOP)\/lib\/lua\/$V$/;"	m
INSTALL_DATA	Makefile	/^INSTALL_DATA= $(INSTALL) -m 0644$/;"	m
INSTALL_EXEC	Makefile	/^INSTALL_EXEC= $(INSTALL) -m 0755$/;"	m
INSTALL_INC	Makefile	/^INSTALL_INC= $(INSTALL_TOP)\/include$/;"	m
INSTALL_LIB	Makefile	/^INSTALL_LIB= $(INSTALL_TOP)\/lib$/;"	m
INSTALL_LMOD	Makefile	/^INSTALL_LMOD= $(INSTALL_TOP)\/share\/lua\/$V$/;"	m
INSTALL_MAN	Makefile	/^INSTALL_MAN= $(INSTALL_TOP)\/man\/man1$/;"	m
INSTALL_TOP	Makefile	/^INSTALL_TOP= \/usr\/local$/;"	m
MKDIR	Makefile	/^MKDIR= mkdir -p$/;"	m
PLAT	Makefile	/^PLAT= none$/;"	m
PLATS	Makefile	/^PLATS= aix ansi bsd freebsd generic linux macosx mingw posix solaris$/;"	m
R	Makefile	/^R= 5.1.5$/;"	m
RANLIB	Makefile	/^RANLIB= ranlib$/;"	m
TO_BIN	Makefile	/^TO_BIN= lua luac$/;"	m
TO_INC	Makefile	/^TO_INC= lua.h luaconf.h lualib.h lauxlib.h ..\/etc\/lua.hpp$/;"	m
TO_LIB	Makefile	/^TO_LIB= liblua.a$/;"	m
TO_MAN	Makefile	/^TO_MAN= lua.1 luac.1$/;"	m
V	Makefile	/^V= 5.1$/;"	m
contents	doc/contents.html	/^<H2><A NAME="contents">Contents<\/A><\/H2>$/;"	a
functions	doc/contents.html	/^<H3><A NAME="functions">Lua functions<\/A><\/H3>$/;"	a
index	doc/contents.html	/^<H2><A NAME="index">Index<\/A><\/H2>$/;"	a
1	doc/manual.html	/^<h1>1 - <a name="1">Introduction<\/a><\/h1>$/;"	a
2	doc/manual.html	/^<h1>2 - <a name="2">The Language<\/a><\/h1>$/;"	a
2.1	doc/manual.html	/^<h2>2.1 - <a name="2.1">Lexical Conventions<\/a><\/h2>$/;"	a
2.10	doc/manual.html	/^<h2>2.10 - <a name="2.10">Garbage Collection<\/a><\/h2>$/;"	a
2.10.1	doc/manual.html	/^<h3>2.10.1 - <a name="2.10.1">Garbage-Collection Metamethods<\/a><\/h3>$/;"	a
2.10.2	doc/manual.html	/^<h3>2.10.2 - <a name="2.10.2">Weak Tables<\/a><\/h3>$/;"	a
2.11	doc/manual.html	/^<h2>2.11 - <a name="2.11">Coroutines<\/a><\/h2>$/;"	a
2.2	doc/manual.html	/^<h2>2.2 - <a name="2.2">Values and Types<\/a><\/h2>$/;"	a
2.2.1	doc/manual.html	/^<h3>2.2.1 - <a name="2.2.1">Coercion<\/a><\/h3>$/;"	a
2.3	doc/manual.html	/^<h2>2.3 - <a name="2.3">Variables<\/a><\/h2>$/;"	a
2.4	doc/manual.html	/^<h2>2.4 - <a name="2.4">Statements<\/a><\/h2>$/;"	a
2.4.1	doc/manual.html	/^<h3>2.4.1 - <a name="2.4.1">Chunks<\/a><\/h3>$/;"	a
2.4.2	doc/manual.html	/^<h3>2.4.2 - <a name="2.4.2">Blocks<\/a><\/h3><p>$/;"	a
2.4.3	doc/manual.html	/^<h3>2.4.3 - <a name="2.4.3">Assignment<\/a><\/h3>$/;"	a
2.4.4	doc/manual.html	/^<h3>2.4.4 - <a name="2.4.4">Control Structures<\/a><\/h3><p>$/;"	a
2.4.5	doc/manual.html	/^<h3>2.4.5 - <a name="2.4.5">For Statement<\/a><\/h3>$/;"	a
2.4.6	doc/manual.html	/^<h3>2.4.6 - <a name="2.4.6">Function Calls as Statements<\/a><\/h3><p>$/;"	a
2.4.7	doc/manual.html	/^<h3>2.4.7 - <a name="2.4.7">Local Declarations<\/a><\/h3><p>$/;"	a
2.5	doc/manual.html	/^<h2>2.5 - <a name="2.5">Expressions<\/a><\/h2>$/;"	a
2.5.1	doc/manual.html	/^<h3>2.5.1 - <a name="2.5.1">Arithmetic Operators<\/a><\/h3><p>$/;"	a
2.5.2	doc/manual.html	/^<h3>2.5.2 - <a name="2.5.2">Relational Operators<\/a><\/h3><p>$/;"	a
2.5.3	doc/manual.html	/^<h3>2.5.3 - <a name="2.5.3">Logical Operators<\/a><\/h3><p>$/;"	a
2.5.4	doc/manual.html	/^<h3>2.5.4 - <a name="2.5.4">Concatenation<\/a><\/h3><p>$/;"	a
2.5.5	doc/manual.html	/^<h3>2.5.5 - <a name="2.5.5">The Length Operator<\/a><\/h3>$/;"	a
2.5.6	doc/manual.html	/^<h3>2.5.6 - <a name="2.5.6">Precedence<\/a><\/h3><p>$/;"	a
2.5.7	doc/manual.html	/^<h3>2.5.7 - <a name="2.5.7">Table Constructors<\/a><\/h3><p>$/;"	a
2.5.8	doc/manual.html	/^<h3>2.5.8 - <a name="2.5.8">Function Calls<\/a><\/h3><p>$/;"	a
2.5.9	doc/manual.html	/^<h3>2.5.9 - <a name="2.5.9">Function Definitions<\/a><\/h3>$/;"	a
2.6	doc/manual.html	/^<h2>2.6 - <a name="2.6">Visibility Rules<\/a><\/h2>$/;"	a
2.7	doc/manual.html	/^<h2>2.7 - <a name="2.7">Error Handling<\/a><\/h2>$/;"	a
2.8	doc/manual.html	/^<h2>2.8 - <a name="2.8">Metatables<\/a><\/h2>$/;"	a
2.9	doc/manual.html	/^<h2>2.9 - <a name="2.9">Environments<\/a><\/h2>$/;"	a
3	doc/manual.html	/^<h1>3 - <a name="3">The Application Program Interface<\/a><\/h1>$/;"	a
3.1	doc/manual.html	/^<h2>3.1 - <a name="3.1">The Stack<\/a><\/h2>$/;"	a
3.2	doc/manual.html	/^<h2>3.2 - <a name="3.2">Stack Size<\/a><\/h2>$/;"	a
3.3	doc/manual.html	/^<h2>3.3 - <a name="3.3">Pseudo-Indices<\/a><\/h2>$/;"	a
3.4	doc/manual.html	/^<h2>3.4 - <a name="3.4">C Closures<\/a><\/h2>$/;"	a
3.5	doc/manual.html	/^<h2>3.5 - <a name="3.5">Registry<\/a><\/h2>$/;"	a
3.6	doc/manual.html	/^<h2>3.6 - <a name="3.6">Error Handling in C<\/a><\/h2>$/;"	a
3.7	doc/manual.html	/^<h2>3.7 - <a name="3.7">Functions and Types<\/a><\/h2>$/;"	a
3.8	doc/manual.html	/^<h2>3.8 - <a name="3.8">The Debug Interface<\/a><\/h2>$/;"	a
4	doc/manual.html	/^<h1>4 - <a name="4">The Auxiliary Library<\/a><\/h1>$/;"	a
4.1	doc/manual.html	/^<h2>4.1 - <a name="4.1">Functions and Types<\/a><\/h2>$/;"	a
5	doc/manual.html	/^<h1>5 - <a name="5">Standard Libraries<\/a><\/h1>$/;"	a
5.1	doc/manual.html	/^<h2>5.1 - <a name="5.1">Basic Functions<\/a><\/h2>$/;"	a
5.2	doc/manual.html	/^<h2>5.2 - <a name="5.2">Coroutine Manipulation<\/a><\/h2>$/;"	a
5.3	doc/manual.html	/^<h2>5.3 - <a name="5.3">Modules<\/a><\/h2>$/;"	a
5.4	doc/manual.html	/^<h2>5.4 - <a name="5.4">String Manipulation<\/a><\/h2>$/;"	a
5.4.1	doc/manual.html	/^<h3>5.4.1 - <a name="5.4.1">Patterns<\/a><\/h3>$/;"	a
5.5	doc/manual.html	/^<h2>5.5 - <a name="5.5">Table Manipulation<\/a><\/h2><p>$/;"	a
5.6	doc/manual.html	/^<h2>5.6 - <a name="5.6">Mathematical Functions<\/a><\/h2>$/;"	a
5.7	doc/manual.html	/^<h2>5.7 - <a name="5.7">Input and Output Facilities<\/a><\/h2>$/;"	a
5.8	doc/manual.html	/^<h2>5.8 - <a name="5.8">Operating System Facilities<\/a><\/h2>$/;"	a
5.9	doc/manual.html	/^<h2>5.9 - <a name="5.9">The Debug Library<\/a><\/h2>$/;"	a
6	doc/manual.html	/^<h1>6 - <a name="6">Lua Stand-alone<\/a><\/h1>$/;"	a
7	doc/manual.html	/^<h1>7 - <a name="7">Incompatibilities with the Previous Version<\/a><\/h1>$/;"	a
7.1	doc/manual.html	/^<h2>7.1 - <a name="7.1">Changes in the Language<\/a><\/h2>$/;"	a
7.2	doc/manual.html	/^<h2>7.2 - <a name="7.2">Changes in the Libraries<\/a><\/h2>$/;"	a
7.3	doc/manual.html	/^<h2>7.3 - <a name="7.3">Changes in the API<\/a><\/h2>$/;"	a
8	doc/manual.html	/^<h1>8 - <a name="8">The Complete Syntax of Lua<\/a><\/h1>$/;"	a
add_event	doc/manual.html	/^     function add_event (op1, op2)$/;"	f
concat_event	doc/manual.html	/^     function concat_event (op1, op2)$/;"	f
eq_event	doc/manual.html	/^     function eq_event (op1, op2)$/;"	f
f	doc/manual.html	/^     function f () <em>body<\/em> end$/;"	f
f	doc/manual.html	/^     function f(a, b) end$/;"	f
foo	doc/manual.html	/^     function foo (a)$/;"	f
function_event	doc/manual.html	/^     function function_event (func, ...)$/;"	f
g	doc/manual.html	/^     function g(a, b, ...) end$/;"	f
gc_event	doc/manual.html	/^     function gc_event (udata)$/;"	f
getbinhandler	doc/manual.html	/^     function getbinhandler (op1, op2, event)$/;"	f
getcomphandler	doc/manual.html	/^     function getcomphandler (op1, op2, event)$/;"	f
gettable_event	doc/manual.html	/^     function gettable_event (table, key)$/;"	f
le_event	doc/manual.html	/^     function le_event (op1, op2)$/;"	f
len_event	doc/manual.html	/^     function len_event (op)$/;"	f
lt_event	doc/manual.html	/^     function lt_event (op1, op2)$/;"	f
luaL_Buffer	doc/manual.html	/^<hr><h3><a name="luaL_Buffer"><code>luaL_Buffer<\/code><\/a><\/h3>$/;"	a
luaL_Reg	doc/manual.html	/^<hr><h3><a name="luaL_Reg"><code>luaL_Reg<\/code><\/a><\/h3>$/;"	a
luaL_addchar	doc/manual.html	/^<hr><h3><a name="luaL_addchar"><code>luaL_addchar<\/code><\/a><\/h3><p>$/;"	a
luaL_addlstring	doc/manual.html	/^<hr><h3><a name="luaL_addlstring"><code>luaL_addlstring<\/code><\/a><\/h3><p>$/;"	a
luaL_addsize	doc/manual.html	/^<hr><h3><a name="luaL_addsize"><code>luaL_addsize<\/code><\/a><\/h3><p>$/;"	a
luaL_addstring	doc/manual.html	/^<hr><h3><a name="luaL_addstring"><code>luaL_addstring<\/code><\/a><\/h3><p>$/;"	a
luaL_addvalue	doc/manual.html	/^<hr><h3><a name="luaL_addvalue"><code>luaL_addvalue<\/code><\/a><\/h3><p>$/;"	a
luaL_argcheck	doc/manual.html	/^<hr><h3><a name="luaL_argcheck"><code>luaL_argcheck<\/code><\/a><\/h3><p>$/;"	a
luaL_argerror	doc/manual.html	/^<hr><h3><a name="luaL_argerror"><code>luaL_argerror<\/code><\/a><\/h3><p>$/;"	a
luaL_buffinit	doc/manual.html	/^<hr><h3><a name="luaL_buffinit"><code>luaL_buffinit<\/code><\/a><\/h3><p>$/;"	a
luaL_callmeta	doc/manual.html	/^<hr><h3><a name="luaL_callmeta"><code>luaL_callmeta<\/code><\/a><\/h3><p>$/;"	a
luaL_checkany	doc/manual.html	/^<hr><h3><a name="luaL_checkany"><code>luaL_checkany<\/code><\/a><\/h3><p>$/;"	a
luaL_checkint	doc/manual.html	/^<hr><h3><a name="luaL_checkint"><code>luaL_checkint<\/code><\/a><\/h3><p>$/;"	a
luaL_checkinteger	doc/manual.html	/^<hr><h3><a name="luaL_checkinteger"><code>luaL_checkinteger<\/code><\/a><\/h3><p>$/;"	a
luaL_checklong	doc/manual.html	/^<hr><h3><a name="luaL_checklong"><code>luaL_checklong<\/code><\/a><\/h3><p>$/;"	a
luaL_checklstring	doc/manual.html	/^<hr><h3><a name="luaL_checklstring"><code>luaL_checklstring<\/code><\/a><\/h3><p>$/;"	a
luaL_checknumber	doc/manual.html	/^<hr><h3><a name="luaL_checknumber"><code>luaL_checknumber<\/code><\/a><\/h3><p>$/;"	a
luaL_checkoption	doc/manual.html	/^<hr><h3><a name="luaL_checkoption"><code>luaL_checkoption<\/code><\/a><\/h3><p>$/;"	a
luaL_checkstack	doc/manual.html	/^<hr><h3><a name="luaL_checkstack"><code>luaL_checkstack<\/code><\/a><\/h3><p>$/;"	a
luaL_checkstring	doc/manual.html	/^<hr><h3><a name="luaL_checkstring"><code>luaL_checkstring<\/code><\/a><\/h3><p>$/;"	a
luaL_checktype	doc/manual.html	/^<hr><h3><a name="luaL_checktype"><code>luaL_checktype<\/code><\/a><\/h3><p>$/;"	a
luaL_checkudata	doc/manual.html	/^<hr><h3><a name="luaL_checkudata"><code>luaL_checkudata<\/code><\/a><\/h3><p>$/;"	a
luaL_dofile	doc/manual.html	/^<hr><h3><a name="luaL_dofile"><code>luaL_dofile<\/code><\/a><\/h3><p>$/;"	a
luaL_dostring	doc/manual.html	/^<hr><h3><a name="luaL_dostring"><code>luaL_dostring<\/code><\/a><\/h3><p>$/;"	a
luaL_error	doc/manual.html	/^<hr><h3><a name="luaL_error"><code>luaL_error<\/code><\/a><\/h3><p>$/;"	a
luaL_getmetafield	doc/manual.html	/^<hr><h3><a name="luaL_getmetafield"><code>luaL_getmetafield<\/code><\/a><\/h3><p>$/;"	a
luaL_getmetatable	doc/manual.html	/^<hr><h3><a name="luaL_getmetatable"><code>luaL_getmetatable<\/code><\/a><\/h3><p>$/;"	a
luaL_gsub	doc/manual.html	/^<hr><h3><a name="luaL_gsub"><code>luaL_gsub<\/code><\/a><\/h3><p>$/;"	a
luaL_loadbuffer	doc/manual.html	/^<hr><h3><a name="luaL_loadbuffer"><code>luaL_loadbuffer<\/code><\/a><\/h3><p>$/;"	a
luaL_loadfile	doc/manual.html	/^<hr><h3><a name="luaL_loadfile"><code>luaL_loadfile<\/code><\/a><\/h3><p>$/;"	a
luaL_loadstring	doc/manual.html	/^<hr><h3><a name="luaL_loadstring"><code>luaL_loadstring<\/code><\/a><\/h3><p>$/;"	a
luaL_newmetatable	doc/manual.html	/^<hr><h3><a name="luaL_newmetatable"><code>luaL_newmetatable<\/code><\/a><\/h3><p>$/;"	a
luaL_newstate	doc/manual.html	/^<hr><h3><a name="luaL_newstate"><code>luaL_newstate<\/code><\/a><\/h3><p>$/;"	a
luaL_openlibs	doc/manual.html	/^<hr><h3><a name="luaL_openlibs"><code>luaL_openlibs<\/code><\/a><\/h3><p>$/;"	a
luaL_optint	doc/manual.html	/^<hr><h3><a name="luaL_optint"><code>luaL_optint<\/code><\/a><\/h3><p>$/;"	a
luaL_optinteger	doc/manual.html	/^<hr><h3><a name="luaL_optinteger"><code>luaL_optinteger<\/code><\/a><\/h3><p>$/;"	a
luaL_optlong	doc/manual.html	/^<hr><h3><a name="luaL_optlong"><code>luaL_optlong<\/code><\/a><\/h3><p>$/;"	a
luaL_optlstring	doc/manual.html	/^<hr><h3><a name="luaL_optlstring"><code>luaL_optlstring<\/code><\/a><\/h3><p>$/;"	a
luaL_optnumber	doc/manual.html	/^<hr><h3><a name="luaL_optnumber"><code>luaL_optnumber<\/code><\/a><\/h3><p>$/;"	a
luaL_optstring	doc/manual.html	/^<hr><h3><a name="luaL_optstring"><code>luaL_optstring<\/code><\/a><\/h3><p>$/;"	a
luaL_prepbuffer	doc/manual.html	/^<hr><h3><a name="luaL_prepbuffer"><code>luaL_prepbuffer<\/code><\/a><\/h3><p>$/;"	a
luaL_pushresult	doc/manual.html	/^<hr><h3><a name="luaL_pushresult"><code>luaL_pushresult<\/code><\/a><\/h3><p>$/;"	a
luaL_ref	doc/manual.html	/^<hr><h3><a name="luaL_ref"><code>luaL_ref<\/code><\/a><\/h3><p>$/;"	a
luaL_register	doc/manual.html	/^<hr><h3><a name="luaL_register"><code>luaL_register<\/code><\/a><\/h3><p>$/;"	a
luaL_typename	doc/manual.html	/^<hr><h3><a name="luaL_typename"><code>luaL_typename<\/code><\/a><\/h3><p>$/;"	a
luaL_typerror	doc/manual.html	/^<hr><h3><a name="luaL_typerror"><code>luaL_typerror<\/code><\/a><\/h3><p>$/;"	a
luaL_unref	doc/manual.html	/^<hr><h3><a name="luaL_unref"><code>luaL_unref<\/code><\/a><\/h3><p>$/;"	a
luaL_where	doc/manual.html	/^<hr><h3><a name="luaL_where"><code>luaL_where<\/code><\/a><\/h3><p>$/;"	a
lua_Alloc	doc/manual.html	/^<hr><h3><a name="lua_Alloc"><code>lua_Alloc<\/code><\/a><\/h3>$/;"	a
lua_CFunction	doc/manual.html	/^<hr><h3><a name="lua_CFunction"><code>lua_CFunction<\/code><\/a><\/h3>$/;"	a
lua_Debug	doc/manual.html	/^<hr><h3><a name="lua_Debug"><code>lua_Debug<\/code><\/a><\/h3>$/;"	a
lua_Hook	doc/manual.html	/^<hr><h3><a name="lua_Hook"><code>lua_Hook<\/code><\/a><\/h3>$/;"	a
lua_Integer	doc/manual.html	/^<hr><h3><a name="lua_Integer"><code>lua_Integer<\/code><\/a><\/h3>$/;"	a
lua_Number	doc/manual.html	/^<hr><h3><a name="lua_Number"><code>lua_Number<\/code><\/a><\/h3>$/;"	a
lua_Reader	doc/manual.html	/^<hr><h3><a name="lua_Reader"><code>lua_Reader<\/code><\/a><\/h3>$/;"	a
lua_State	doc/manual.html	/^<hr><h3><a name="lua_State"><code>lua_State<\/code><\/a><\/h3>$/;"	a
lua_Writer	doc/manual.html	/^<hr><h3><a name="lua_Writer"><code>lua_Writer<\/code><\/a><\/h3>$/;"	a
lua_atpanic	doc/manual.html	/^<hr><h3><a name="lua_atpanic"><code>lua_atpanic<\/code><\/a><\/h3><p>$/;"	a
lua_call	doc/manual.html	/^<hr><h3><a name="lua_call"><code>lua_call<\/code><\/a><\/h3><p>$/;"	a
lua_checkstack	doc/manual.html	/^<hr><h3><a name="lua_checkstack"><code>lua_checkstack<\/code><\/a><\/h3><p>$/;"	a
lua_close	doc/manual.html	/^<hr><h3><a name="lua_close"><code>lua_close<\/code><\/a><\/h3><p>$/;"	a
lua_concat	doc/manual.html	/^<hr><h3><a name="lua_concat"><code>lua_concat<\/code><\/a><\/h3><p>$/;"	a
lua_cpcall	doc/manual.html	/^<hr><h3><a name="lua_cpcall"><code>lua_cpcall<\/code><\/a><\/h3><p>$/;"	a
lua_createtable	doc/manual.html	/^<hr><h3><a name="lua_createtable"><code>lua_createtable<\/code><\/a><\/h3><p>$/;"	a
lua_dump	doc/manual.html	/^<hr><h3><a name="lua_dump"><code>lua_dump<\/code><\/a><\/h3><p>$/;"	a
lua_equal	doc/manual.html	/^<hr><h3><a name="lua_equal"><code>lua_equal<\/code><\/a><\/h3><p>$/;"	a
lua_error	doc/manual.html	/^<hr><h3><a name="lua_error"><code>lua_error<\/code><\/a><\/h3><p>$/;"	a
lua_gc	doc/manual.html	/^<hr><h3><a name="lua_gc"><code>lua_gc<\/code><\/a><\/h3><p>$/;"	a
lua_getallocf	doc/manual.html	/^<hr><h3><a name="lua_getallocf"><code>lua_getallocf<\/code><\/a><\/h3><p>$/;"	a
lua_getfenv	doc/manual.html	/^<hr><h3><a name="lua_getfenv"><code>lua_getfenv<\/code><\/a><\/h3><p>$/;"	a
lua_getfield	doc/manual.html	/^<hr><h3><a name="lua_getfield"><code>lua_getfield<\/code><\/a><\/h3><p>$/;"	a
lua_getglobal	doc/manual.html	/^<hr><h3><a name="lua_getglobal"><code>lua_getglobal<\/code><\/a><\/h3><p>$/;"	a
lua_gethook	doc/manual.html	/^<hr><h3><a name="lua_gethook"><code>lua_gethook<\/code><\/a><\/h3><p>$/;"	a
lua_gethookcount	doc/manual.html	/^<hr><h3><a name="lua_gethookcount"><code>lua_gethookcount<\/code><\/a><\/h3><p>$/;"	a
lua_gethookmask	doc/manual.html	/^<hr><h3><a name="lua_gethookmask"><code>lua_gethookmask<\/code><\/a><\/h3><p>$/;"	a
lua_getinfo	doc/manual.html	/^<hr><h3><a name="lua_getinfo"><code>lua_getinfo<\/code><\/a><\/h3><p>$/;"	a
lua_getlocal	doc/manual.html	/^<hr><h3><a name="lua_getlocal"><code>lua_getlocal<\/code><\/a><\/h3><p>$/;"	a
lua_getmetatable	doc/manual.html	/^<hr><h3><a name="lua_getmetatable"><code>lua_getmetatable<\/code><\/a><\/h3><p>$/;"	a
lua_getstack	doc/manual.html	/^<hr><h3><a name="lua_getstack"><code>lua_getstack<\/code><\/a><\/h3><p>$/;"	a
lua_gettable	doc/manual.html	/^<hr><h3><a name="lua_gettable"><code>lua_gettable<\/code><\/a><\/h3><p>$/;"	a
lua_gettop	doc/manual.html	/^<hr><h3><a name="lua_gettop"><code>lua_gettop<\/code><\/a><\/h3><p>$/;"	a
lua_getupvalue	doc/manual.html	/^<hr><h3><a name="lua_getupvalue"><code>lua_getupvalue<\/code><\/a><\/h3><p>$/;"	a
lua_insert	doc/manual.html	/^<hr><h3><a name="lua_insert"><code>lua_insert<\/code><\/a><\/h3><p>$/;"	a
lua_isboolean	doc/manual.html	/^<hr><h3><a name="lua_isboolean"><code>lua_isboolean<\/code><\/a><\/h3><p>$/;"	a
lua_iscfunction	doc/manual.html	/^<hr><h3><a name="lua_iscfunction"><code>lua_iscfunction<\/code><\/a><\/h3><p>$/;"	a
lua_isfunction	doc/manual.html	/^<hr><h3><a name="lua_isfunction"><code>lua_isfunction<\/code><\/a><\/h3><p>$/;"	a
lua_islightuserdata	doc/manual.html	/^<hr><h3><a name="lua_islightuserdata"><code>lua_islightuserdata<\/code><\/a><\/h3><p>$/;"	a
lua_isnil	doc/manual.html	/^<hr><h3><a name="lua_isnil"><code>lua_isnil<\/code><\/a><\/h3><p>$/;"	a
lua_isnone	doc/manual.html	/^<hr><h3><a name="lua_isnone"><code>lua_isnone<\/code><\/a><\/h3><p>$/;"	a
lua_isnoneornil	doc/manual.html	/^<hr><h3><a name="lua_isnoneornil"><code>lua_isnoneornil<\/code><\/a><\/h3><p>$/;"	a
lua_isnumber	doc/manual.html	/^<hr><h3><a name="lua_isnumber"><code>lua_isnumber<\/code><\/a><\/h3><p>$/;"	a
lua_isstring	doc/manual.html	/^<hr><h3><a name="lua_isstring"><code>lua_isstring<\/code><\/a><\/h3><p>$/;"	a
lua_istable	doc/manual.html	/^<hr><h3><a name="lua_istable"><code>lua_istable<\/code><\/a><\/h3><p>$/;"	a
lua_isthread	doc/manual.html	/^<hr><h3><a name="lua_isthread"><code>lua_isthread<\/code><\/a><\/h3><p>$/;"	a
lua_isuserdata	doc/manual.html	/^<hr><h3><a name="lua_isuserdata"><code>lua_isuserdata<\/code><\/a><\/h3><p>$/;"	a
lua_lessthan	doc/manual.html	/^<hr><h3><a name="lua_lessthan"><code>lua_lessthan<\/code><\/a><\/h3><p>$/;"	a
lua_load	doc/manual.html	/^<hr><h3><a name="lua_load"><code>lua_load<\/code><\/a><\/h3><p>$/;"	a
lua_newstate	doc/manual.html	/^<hr><h3><a name="lua_newstate"><code>lua_newstate<\/code><\/a><\/h3><p>$/;"	a
lua_newtable	doc/manual.html	/^<hr><h3><a name="lua_newtable"><code>lua_newtable<\/code><\/a><\/h3><p>$/;"	a
lua_newthread	doc/manual.html	/^<hr><h3><a name="lua_newthread"><code>lua_newthread<\/code><\/a><\/h3><p>$/;"	a
lua_newuserdata	doc/manual.html	/^<hr><h3><a name="lua_newuserdata"><code>lua_newuserdata<\/code><\/a><\/h3><p>$/;"	a
lua_next	doc/manual.html	/^<hr><h3><a name="lua_next"><code>lua_next<\/code><\/a><\/h3><p>$/;"	a
lua_objlen	doc/manual.html	/^<hr><h3><a name="lua_objlen"><code>lua_objlen<\/code><\/a><\/h3><p>$/;"	a
lua_pcall	doc/manual.html	/^<hr><h3><a name="lua_pcall"><code>lua_pcall<\/code><\/a><\/h3><p>$/;"	a
lua_pop	doc/manual.html	/^<hr><h3><a name="lua_pop"><code>lua_pop<\/code><\/a><\/h3><p>$/;"	a
lua_pushboolean	doc/manual.html	/^<hr><h3><a name="lua_pushboolean"><code>lua_pushboolean<\/code><\/a><\/h3><p>$/;"	a
lua_pushcclosure	doc/manual.html	/^<hr><h3><a name="lua_pushcclosure"><code>lua_pushcclosure<\/code><\/a><\/h3><p>$/;"	a
lua_pushcfunction	doc/manual.html	/^<hr><h3><a name="lua_pushcfunction"><code>lua_pushcfunction<\/code><\/a><\/h3><p>$/;"	a
lua_pushfstring	doc/manual.html	/^<hr><h3><a name="lua_pushfstring"><code>lua_pushfstring<\/code><\/a><\/h3><p>$/;"	a
lua_pushinteger	doc/manual.html	/^<hr><h3><a name="lua_pushinteger"><code>lua_pushinteger<\/code><\/a><\/h3><p>$/;"	a
lua_pushlightuserdata	doc/manual.html	/^<hr><h3><a name="lua_pushlightuserdata"><code>lua_pushlightuserdata<\/code><\/a><\/h3><p>$/;"	a
lua_pushliteral	doc/manual.html	/^<hr><h3><a name="lua_pushliteral"><code>lua_pushliteral<\/code><\/a><\/h3><p>$/;"	a
lua_pushlstring	doc/manual.html	/^<hr><h3><a name="lua_pushlstring"><code>lua_pushlstring<\/code><\/a><\/h3><p>$/;"	a
lua_pushnil	doc/manual.html	/^<hr><h3><a name="lua_pushnil"><code>lua_pushnil<\/code><\/a><\/h3><p>$/;"	a
lua_pushnumber	doc/manual.html	/^<hr><h3><a name="lua_pushnumber"><code>lua_pushnumber<\/code><\/a><\/h3><p>$/;"	a
lua_pushstring	doc/manual.html	/^<hr><h3><a name="lua_pushstring"><code>lua_pushstring<\/code><\/a><\/h3><p>$/;"	a
lua_pushthread	doc/manual.html	/^<hr><h3><a name="lua_pushthread"><code>lua_pushthread<\/code><\/a><\/h3><p>$/;"	a
lua_pushvalue	doc/manual.html	/^<hr><h3><a name="lua_pushvalue"><code>lua_pushvalue<\/code><\/a><\/h3><p>$/;"	a
lua_pushvfstring	doc/manual.html	/^<hr><h3><a name="lua_pushvfstring"><code>lua_pushvfstring<\/code><\/a><\/h3><p>$/;"	a
lua_rawequal	doc/manual.html	/^<hr><h3><a name="lua_rawequal"><code>lua_rawequal<\/code><\/a><\/h3><p>$/;"	a
lua_rawget	doc/manual.html	/^<hr><h3><a name="lua_rawget"><code>lua_rawget<\/code><\/a><\/h3><p>$/;"	a
lua_rawgeti	doc/manual.html	/^<hr><h3><a name="lua_rawgeti"><code>lua_rawgeti<\/code><\/a><\/h3><p>$/;"	a
lua_rawset	doc/manual.html	/^<hr><h3><a name="lua_rawset"><code>lua_rawset<\/code><\/a><\/h3><p>$/;"	a
lua_rawseti	doc/manual.html	/^<hr><h3><a name="lua_rawseti"><code>lua_rawseti<\/code><\/a><\/h3><p>$/;"	a
lua_register	doc/manual.html	/^<hr><h3><a name="lua_register"><code>lua_register<\/code><\/a><\/h3><p>$/;"	a
lua_remove	doc/manual.html	/^<hr><h3><a name="lua_remove"><code>lua_remove<\/code><\/a><\/h3><p>$/;"	a
lua_replace	doc/manual.html	/^<hr><h3><a name="lua_replace"><code>lua_replace<\/code><\/a><\/h3><p>$/;"	a
lua_resume	doc/manual.html	/^<hr><h3><a name="lua_resume"><code>lua_resume<\/code><\/a><\/h3><p>$/;"	a
lua_setallocf	doc/manual.html	/^<hr><h3><a name="lua_setallocf"><code>lua_setallocf<\/code><\/a><\/h3><p>$/;"	a
lua_setfenv	doc/manual.html	/^<hr><h3><a name="lua_setfenv"><code>lua_setfenv<\/code><\/a><\/h3><p>$/;"	a
lua_setfield	doc/manual.html	/^<hr><h3><a name="lua_setfield"><code>lua_setfield<\/code><\/a><\/h3><p>$/;"	a
lua_setglobal	doc/manual.html	/^<hr><h3><a name="lua_setglobal"><code>lua_setglobal<\/code><\/a><\/h3><p>$/;"	a
lua_sethook	doc/manual.html	/^<hr><h3><a name="lua_sethook"><code>lua_sethook<\/code><\/a><\/h3><p>$/;"	a
lua_setlocal	doc/manual.html	/^<hr><h3><a name="lua_setlocal"><code>lua_setlocal<\/code><\/a><\/h3><p>$/;"	a
lua_setmetatable	doc/manual.html	/^<hr><h3><a name="lua_setmetatable"><code>lua_setmetatable<\/code><\/a><\/h3><p>$/;"	a
lua_settable	doc/manual.html	/^<hr><h3><a name="lua_settable"><code>lua_settable<\/code><\/a><\/h3><p>$/;"	a
lua_settop	doc/manual.html	/^<hr><h3><a name="lua_settop"><code>lua_settop<\/code><\/a><\/h3><p>$/;"	a
lua_setupvalue	doc/manual.html	/^<hr><h3><a name="lua_setupvalue"><code>lua_setupvalue<\/code><\/a><\/h3><p>$/;"	a
lua_status	doc/manual.html	/^<hr><h3><a name="lua_status"><code>lua_status<\/code><\/a><\/h3><p>$/;"	a
lua_toboolean	doc/manual.html	/^<hr><h3><a name="lua_toboolean"><code>lua_toboolean<\/code><\/a><\/h3><p>$/;"	a
lua_tocfunction	doc/manual.html	/^<hr><h3><a name="lua_tocfunction"><code>lua_tocfunction<\/code><\/a><\/h3><p>$/;"	a
lua_tointeger	doc/manual.html	/^<hr><h3><a name="lua_tointeger"><code>lua_tointeger<\/code><\/a><\/h3><p>$/;"	a
lua_tolstring	doc/manual.html	/^<hr><h3><a name="lua_tolstring"><code>lua_tolstring<\/code><\/a><\/h3><p>$/;"	a
lua_tonumber	doc/manual.html	/^<hr><h3><a name="lua_tonumber"><code>lua_tonumber<\/code><\/a><\/h3><p>$/;"	a
lua_topointer	doc/manual.html	/^<hr><h3><a name="lua_topointer"><code>lua_topointer<\/code><\/a><\/h3><p>$/;"	a
lua_tostring	doc/manual.html	/^<hr><h3><a name="lua_tostring"><code>lua_tostring<\/code><\/a><\/h3><p>$/;"	a
lua_tothread	doc/manual.html	/^<hr><h3><a name="lua_tothread"><code>lua_tothread<\/code><\/a><\/h3><p>$/;"	a
lua_touserdata	doc/manual.html	/^<hr><h3><a name="lua_touserdata"><code>lua_touserdata<\/code><\/a><\/h3><p>$/;"	a
lua_type	doc/manual.html	/^<hr><h3><a name="lua_type"><code>lua_type<\/code><\/a><\/h3><p>$/;"	a
lua_typename	doc/manual.html	/^<hr><h3><a name="lua_typename"><code>lua_typename<\/code><\/a><\/h3><p>$/;"	a
lua_upvalueindex	doc/manual.html	/^<a name="lua_upvalueindex"><code>lua_upvalueindex<\/code><\/a>.$/;"	a
lua_xmove	doc/manual.html	/^<hr><h3><a name="lua_xmove"><code>lua_xmove<\/code><\/a><\/h3><p>$/;"	a
lua_yield	doc/manual.html	/^<hr><h3><a name="lua_yield"><code>lua_yield<\/code><\/a><\/h3><p>$/;"	a
pdf-LUAL_BUFFERSIZE	doc/manual.html	/^Returns an address to a space of size <a name="pdf-LUAL_BUFFERSIZE"><code>LUAL_BUFFERSIZE<\/code><\/a>$/;"	a
pdf-LUA_CPATH	doc/manual.html	/^using the environment variable <a name="pdf-LUA_CPATH"><code>LUA_CPATH<\/code><\/a>$/;"	a
pdf-LUA_ENVIRONINDEX	doc/manual.html	/^at pseudo-index <a name="pdf-LUA_ENVIRONINDEX"><code>LUA_ENVIRONINDEX<\/code><\/a>.$/;"	a
pdf-LUA_ERRERR	doc/manual.html	/^<li><b><a name="pdf-LUA_ERRERR"><code>LUA_ERRERR<\/code><\/a>:<\/b>$/;"	a
pdf-LUA_ERRFILE	doc/manual.html	/^but it has an extra error code <a name="pdf-LUA_ERRFILE"><code>LUA_ERRFILE<\/code><\/a>$/;"	a
pdf-LUA_ERRMEM	doc/manual.html	/^<li><b><a name="pdf-LUA_ERRMEM"><code>LUA_ERRMEM<\/code><\/a>:<\/b>$/;"	a
pdf-LUA_ERRRUN	doc/manual.html	/^<li><b><a name="pdf-LUA_ERRRUN"><code>LUA_ERRRUN<\/code><\/a>:<\/b>$/;"	a
pdf-LUA_ERRSYNTAX	doc/manual.html	/^<li><b><a name="pdf-LUA_ERRSYNTAX"><code>LUA_ERRSYNTAX<\/code><\/a>:<\/b>$/;"	a
pdf-LUA_GLOBALSINDEX	doc/manual.html	/^always at pseudo-index <a name="pdf-LUA_GLOBALSINDEX"><code>LUA_GLOBALSINDEX<\/code><\/a>.$/;"	a
pdf-LUA_HOOKCALL	doc/manual.html	/^<a name="pdf-LUA_HOOKCALL"><code>LUA_HOOKCALL<\/code><\/a>, <a name="pdf-LUA_HOOKRET"><code>LUA_HOOKRET<\/code><\/a>,$/;"	a
pdf-LUA_HOOKCOUNT	doc/manual.html	/^and <a name="pdf-LUA_HOOKCOUNT"><code>LUA_HOOKCOUNT<\/code><\/a>.$/;"	a
pdf-LUA_HOOKTAILRET	doc/manual.html	/^<a name="pdf-LUA_HOOKTAILRET"><code>LUA_HOOKTAILRET<\/code><\/a>, <a name="pdf-LUA_HOOKLINE"><code>LUA_HOOKLINE<\/code><\/a>,$/;"	a
pdf-LUA_INIT	doc/manual.html	/^the interpreter checks for an environment variable <a name="pdf-LUA_INIT"><code>LUA_INIT<\/code><\/a>.$/;"	a
pdf-LUA_MASKCALL	doc/manual.html	/^<a name="pdf-LUA_MASKCALL"><code>LUA_MASKCALL<\/code><\/a>,$/;"	a
pdf-LUA_MASKCOUNT	doc/manual.html	/^and <a name="pdf-LUA_MASKCOUNT"><code>LUA_MASKCOUNT<\/code><\/a>.$/;"	a
pdf-LUA_MASKLINE	doc/manual.html	/^<a name="pdf-LUA_MASKLINE"><code>LUA_MASKLINE<\/code><\/a>,$/;"	a
pdf-LUA_MASKRET	doc/manual.html	/^<a name="pdf-LUA_MASKRET"><code>LUA_MASKRET<\/code><\/a>,$/;"	a
pdf-LUA_MINSTACK	doc/manual.html	/^it ensures that at least <a name="pdf-LUA_MINSTACK"><code>LUA_MINSTACK<\/code><\/a> stack positions are available.$/;"	a
pdf-LUA_MULTRET	doc/manual.html	/^unless <code>nresults<\/code> is <a name="pdf-LUA_MULTRET"><code>LUA_MULTRET<\/code><\/a>.$/;"	a
pdf-LUA_NOREF	doc/manual.html	/^The constant <a name="pdf-LUA_NOREF"><code>LUA_NOREF<\/code><\/a> is guaranteed to be different$/;"	a
pdf-LUA_PATH	doc/manual.html	/^the value of the environment variable <a name="pdf-LUA_PATH"><code>LUA_PATH<\/code><\/a> or$/;"	a
pdf-LUA_REFNIL	doc/manual.html	/^<a href="#luaL_ref"><code>luaL_ref<\/code><\/a> returns the constant <a name="pdf-LUA_REFNIL"><code>LUA_REFNIL<\/code><\/a>.$/;"	a
pdf-LUA_REGISTRYINDEX	doc/manual.html	/^<a name="pdf-LUA_REGISTRYINDEX"><code>LUA_REGISTRYINDEX<\/code><\/a>.$/;"	a
pdf-LUA_YIELD	doc/manual.html	/^or <a name="pdf-LUA_YIELD"><code>LUA_YIELD<\/code><\/a> if the thread is suspended.$/;"	a
pdf-_G	doc/manual.html	/^<hr><h3><a name="pdf-_G"><code>_G<\/code><\/a><\/h3>$/;"	a
pdf-_PROMPT	doc/manual.html	/^If the global variable <a name="pdf-_PROMPT"><code>_PROMPT<\/code><\/a> contains a string,$/;"	a
pdf-_PROMPT2	doc/manual.html	/^Similarly, if the global variable <a name="pdf-_PROMPT2"><code>_PROMPT2<\/code><\/a> contains a string,$/;"	a
pdf-_VERSION	doc/manual.html	/^<hr><h3><a name="pdf-_VERSION"><code>_VERSION<\/code><\/a><\/h3>$/;"	a
pdf-assert	doc/manual.html	/^<hr><h3><a name="pdf-assert"><code>assert (v [, message])<\/code><\/a><\/h3>$/;"	a
pdf-collectgarbage	doc/manual.html	/^<hr><h3><a name="pdf-collectgarbage"><code>collectgarbage ([opt [, arg]])<\/code><\/a><\/h3>$/;"	a
pdf-coroutine	doc/manual.html	/^the basic library and come inside the table <a name="pdf-coroutine"><code>coroutine<\/code><\/a>.$/;"	a
pdf-coroutine.create	doc/manual.html	/^<hr><h3><a name="pdf-coroutine.create"><code>coroutine.create (f)<\/code><\/a><\/h3>$/;"	a
pdf-coroutine.resume	doc/manual.html	/^<hr><h3><a name="pdf-coroutine.resume"><code>coroutine.resume (co [, val1, &middot;&middot;&middot;])<\/code><\/a><\/h3>$/;"	a
pdf-coroutine.running	doc/manual.html	/^<hr><h3><a name="pdf-coroutine.running"><code>coroutine.running ()<\/code><\/a><\/h3>$/;"	a
pdf-coroutine.status	doc/manual.html	/^<hr><h3><a name="pdf-coroutine.status"><code>coroutine.status (co)<\/code><\/a><\/h3>$/;"	a
pdf-coroutine.wrap	doc/manual.html	/^<hr><h3><a name="pdf-coroutine.wrap"><code>coroutine.wrap (f)<\/code><\/a><\/h3>$/;"	a
pdf-coroutine.yield	doc/manual.html	/^<hr><h3><a name="pdf-coroutine.yield"><code>coroutine.yield (&middot;&middot;&middot;)<\/code><\/a><\/h3>$/;"	a
pdf-debug	doc/manual.html	/^inside the <a name="pdf-debug"><code>debug<\/code><\/a> table.$/;"	a
pdf-debug.debug	doc/manual.html	/^<hr><h3><a name="pdf-debug.debug"><code>debug.debug ()<\/code><\/a><\/h3>$/;"	a
pdf-debug.getfenv	doc/manual.html	/^<hr><h3><a name="pdf-debug.getfenv"><code>debug.getfenv (o)<\/code><\/a><\/h3>$/;"	a
pdf-debug.gethook	doc/manual.html	/^<hr><h3><a name="pdf-debug.gethook"><code>debug.gethook ([thread])<\/code><\/a><\/h3>$/;"	a
pdf-debug.getinfo	doc/manual.html	/^<hr><h3><a name="pdf-debug.getinfo"><code>debug.getinfo ([thread,] function [, what])<\/code><\/a><\/h3>$/;"	a
pdf-debug.getlocal	doc/manual.html	/^<hr><h3><a name="pdf-debug.getlocal"><code>debug.getlocal ([thread,] level, local)<\/code><\/a><\/h3>$/;"	a
pdf-debug.getmetatable	doc/manual.html	/^<hr><h3><a name="pdf-debug.getmetatable"><code>debug.getmetatable (object)<\/code><\/a><\/h3>$/;"	a
pdf-debug.getregistry	doc/manual.html	/^<hr><h3><a name="pdf-debug.getregistry"><code>debug.getregistry ()<\/code><\/a><\/h3>$/;"	a
pdf-debug.getupvalue	doc/manual.html	/^<hr><h3><a name="pdf-debug.getupvalue"><code>debug.getupvalue (func, up)<\/code><\/a><\/h3>$/;"	a
pdf-debug.setfenv	doc/manual.html	/^<hr><h3><a name="pdf-debug.setfenv"><code>debug.setfenv (object, table)<\/code><\/a><\/h3>$/;"	a
pdf-debug.sethook	doc/manual.html	/^<hr><h3><a name="pdf-debug.sethook"><code>debug.sethook ([thread,] hook, mask [, count])<\/code><\/a><\/h3>$/;"	a
pdf-debug.setlocal	doc/manual.html	/^<hr><h3><a name="pdf-debug.setlocal"><code>debug.setlocal ([thread,] level, local, value)<\/code><\/a><\/h3>$/;"	a
pdf-debug.setmetatable	doc/manual.html	/^<hr><h3><a name="pdf-debug.setmetatable"><code>debug.setmetatable (object, table)<\/code><\/a><\/h3>$/;"	a
pdf-debug.setupvalue	doc/manual.html	/^<hr><h3><a name="pdf-debug.setupvalue"><code>debug.setupvalue (func, up, value)<\/code><\/a><\/h3>$/;"	a
pdf-debug.traceback	doc/manual.html	/^<hr><h3><a name="pdf-debug.traceback"><code>debug.traceback ([thread,] [message [, level]])<\/code><\/a><\/h3>$/;"	a
pdf-dofile	doc/manual.html	/^<hr><h3><a name="pdf-dofile"><code>dofile ([filename])<\/code><\/a><\/h3>$/;"	a
pdf-error	doc/manual.html	/^<hr><h3><a name="pdf-error"><code>error (message [, level])<\/code><\/a><\/h3>$/;"	a
pdf-file:close	doc/manual.html	/^<hr><h3><a name="pdf-file:close"><code>file:close ()<\/code><\/a><\/h3>$/;"	a
pdf-file:flush	doc/manual.html	/^<hr><h3><a name="pdf-file:flush"><code>file:flush ()<\/code><\/a><\/h3>$/;"	a
pdf-file:lines	doc/manual.html	/^<hr><h3><a name="pdf-file:lines"><code>file:lines ()<\/code><\/a><\/h3>$/;"	a
pdf-file:read	doc/manual.html	/^<hr><h3><a name="pdf-file:read"><code>file:read (&middot;&middot;&middot;)<\/code><\/a><\/h3>$/;"	a
pdf-file:seek	doc/manual.html	/^<hr><h3><a name="pdf-file:seek"><code>file:seek ([whence] [, offset])<\/code><\/a><\/h3>$/;"	a
pdf-file:setvbuf	doc/manual.html	/^<hr><h3><a name="pdf-file:setvbuf"><code>file:setvbuf (mode [, size])<\/code><\/a><\/h3>$/;"	a
pdf-file:write	doc/manual.html	/^<hr><h3><a name="pdf-file:write"><code>file:write (&middot;&middot;&middot;)<\/code><\/a><\/h3>$/;"	a
pdf-getfenv	doc/manual.html	/^<hr><h3><a name="pdf-getfenv"><code>getfenv ([f])<\/code><\/a><\/h3>$/;"	a
pdf-getmetatable	doc/manual.html	/^<hr><h3><a name="pdf-getmetatable"><code>getmetatable (object)<\/code><\/a><\/h3>$/;"	a
pdf-io	doc/manual.html	/^all operations are supplied by table <a name="pdf-io"><code>io<\/code><\/a>.$/;"	a
pdf-io.close	doc/manual.html	/^<hr><h3><a name="pdf-io.close"><code>io.close ([file])<\/code><\/a><\/h3>$/;"	a
pdf-io.flush	doc/manual.html	/^<hr><h3><a name="pdf-io.flush"><code>io.flush ()<\/code><\/a><\/h3>$/;"	a
pdf-io.input	doc/manual.html	/^<hr><h3><a name="pdf-io.input"><code>io.input ([file])<\/code><\/a><\/h3>$/;"	a
pdf-io.lines	doc/manual.html	/^<hr><h3><a name="pdf-io.lines"><code>io.lines ([filename])<\/code><\/a><\/h3>$/;"	a
pdf-io.open	doc/manual.html	/^<hr><h3><a name="pdf-io.open"><code>io.open (filename [, mode])<\/code><\/a><\/h3>$/;"	a
pdf-io.output	doc/manual.html	/^<hr><h3><a name="pdf-io.output"><code>io.output ([file])<\/code><\/a><\/h3>$/;"	a
pdf-io.popen	doc/manual.html	/^<hr><h3><a name="pdf-io.popen"><code>io.popen (prog [, mode])<\/code><\/a><\/h3>$/;"	a
pdf-io.read	doc/manual.html	/^<hr><h3><a name="pdf-io.read"><code>io.read (&middot;&middot;&middot;)<\/code><\/a><\/h3>$/;"	a
pdf-io.stdin	doc/manual.html	/^<a name="pdf-io.stdin"><code>io.stdin<\/code><\/a>, <a name="pdf-io.stdout"><code>io.stdout<\/code><\/a>, and <a name="pdf-io.stderr"><code>io.stderr<\/code><\/a>.$/;"	a
pdf-io.tmpfile	doc/manual.html	/^<hr><h3><a name="pdf-io.tmpfile"><code>io.tmpfile ()<\/code><\/a><\/h3>$/;"	a
pdf-io.type	doc/manual.html	/^<hr><h3><a name="pdf-io.type"><code>io.type (obj)<\/code><\/a><\/h3>$/;"	a
pdf-io.write	doc/manual.html	/^<hr><h3><a name="pdf-io.write"><code>io.write (&middot;&middot;&middot;)<\/code><\/a><\/h3>$/;"	a
pdf-ipairs	doc/manual.html	/^<hr><h3><a name="pdf-ipairs"><code>ipairs (t)<\/code><\/a><\/h3>$/;"	a
pdf-load	doc/manual.html	/^<hr><h3><a name="pdf-load"><code>load (func [, chunkname])<\/code><\/a><\/h3>$/;"	a
pdf-loadfile	doc/manual.html	/^<hr><h3><a name="pdf-loadfile"><code>loadfile ([filename])<\/code><\/a><\/h3>$/;"	a
pdf-loadstring	doc/manual.html	/^<hr><h3><a name="pdf-loadstring"><code>loadstring (string [, chunkname])<\/code><\/a><\/h3>$/;"	a
pdf-lua.h	doc/manual.html	/^are declared in the header file <a name="pdf-lua.h"><code>lua.h<\/code><\/a>.$/;"	a
pdf-luai_apicheck	doc/manual.html	/^with a proper definition for the macro <a name="pdf-luai_apicheck"><code>luai_apicheck<\/code><\/a>,$/;"	a
pdf-lualib.h	doc/manual.html	/^These functions are declared in <a name="pdf-lualib.h"><code>lualib.h<\/code><\/a>$/;"	a
pdf-luaopen_base	doc/manual.html	/^<a name="pdf-luaopen_base"><code>luaopen_base<\/code><\/a> (for the basic library),$/;"	a
pdf-luaopen_debug	doc/manual.html	/^and <a name="pdf-luaopen_debug"><code>luaopen_debug<\/code><\/a> (for the debug library).$/;"	a
pdf-luaopen_io	doc/manual.html	/^<a name="pdf-luaopen_io"><code>luaopen_io<\/code><\/a> (for the I\/O library),$/;"	a
pdf-luaopen_math	doc/manual.html	/^<a name="pdf-luaopen_math"><code>luaopen_math<\/code><\/a> (for the mathematical library),$/;"	a
pdf-luaopen_os	doc/manual.html	/^<a name="pdf-luaopen_os"><code>luaopen_os<\/code><\/a> (for the Operating System library),$/;"	a
pdf-luaopen_package	doc/manual.html	/^<a name="pdf-luaopen_package"><code>luaopen_package<\/code><\/a> (for the package library),$/;"	a
pdf-luaopen_string	doc/manual.html	/^<a name="pdf-luaopen_string"><code>luaopen_string<\/code><\/a> (for the string library),$/;"	a
pdf-luaopen_table	doc/manual.html	/^<a name="pdf-luaopen_table"><code>luaopen_table<\/code><\/a> (for the table library),$/;"	a
pdf-math	doc/manual.html	/^It provides all its functions inside the table <a name="pdf-math"><code>math<\/code><\/a>.$/;"	a
pdf-math.abs	doc/manual.html	/^<hr><h3><a name="pdf-math.abs"><code>math.abs (x)<\/code><\/a><\/h3>$/;"	a
pdf-math.acos	doc/manual.html	/^<hr><h3><a name="pdf-math.acos"><code>math.acos (x)<\/code><\/a><\/h3>$/;"	a
pdf-math.asin	doc/manual.html	/^<hr><h3><a name="pdf-math.asin"><code>math.asin (x)<\/code><\/a><\/h3>$/;"	a
pdf-math.atan	doc/manual.html	/^<hr><h3><a name="pdf-math.atan"><code>math.atan (x)<\/code><\/a><\/h3>$/;"	a
pdf-math.atan2	doc/manual.html	/^<hr><h3><a name="pdf-math.atan2"><code>math.atan2 (y, x)<\/code><\/a><\/h3>$/;"	a
pdf-math.ceil	doc/manual.html	/^<hr><h3><a name="pdf-math.ceil"><code>math.ceil (x)<\/code><\/a><\/h3>$/;"	a
pdf-math.cos	doc/manual.html	/^<hr><h3><a name="pdf-math.cos"><code>math.cos (x)<\/code><\/a><\/h3>$/;"	a
pdf-math.cosh	doc/manual.html	/^<hr><h3><a name="pdf-math.cosh"><code>math.cosh (x)<\/code><\/a><\/h3>$/;"	a
pdf-math.deg	doc/manual.html	/^<hr><h3><a name="pdf-math.deg"><code>math.deg (x)<\/code><\/a><\/h3>$/;"	a
pdf-math.exp	doc/manual.html	/^<hr><h3><a name="pdf-math.exp"><code>math.exp (x)<\/code><\/a><\/h3>$/;"	a
pdf-math.floor	doc/manual.html	/^<hr><h3><a name="pdf-math.floor"><code>math.floor (x)<\/code><\/a><\/h3>$/;"	a
pdf-math.fmod	doc/manual.html	/^<hr><h3><a name="pdf-math.fmod"><code>math.fmod (x, y)<\/code><\/a><\/h3>$/;"	a
pdf-math.frexp	doc/manual.html	/^<hr><h3><a name="pdf-math.frexp"><code>math.frexp (x)<\/code><\/a><\/h3>$/;"	a
pdf-math.huge	doc/manual.html	/^<hr><h3><a name="pdf-math.huge"><code>math.huge<\/code><\/a><\/h3>$/;"	a
pdf-math.ldexp	doc/manual.html	/^<hr><h3><a name="pdf-math.ldexp"><code>math.ldexp (m, e)<\/code><\/a><\/h3>$/;"	a
pdf-math.log	doc/manual.html	/^<hr><h3><a name="pdf-math.log"><code>math.log (x)<\/code><\/a><\/h3>$/;"	a
pdf-math.log10	doc/manual.html	/^<hr><h3><a name="pdf-math.log10"><code>math.log10 (x)<\/code><\/a><\/h3>$/;"	a
pdf-math.max	doc/manual.html	/^<hr><h3><a name="pdf-math.max"><code>math.max (x, &middot;&middot;&middot;)<\/code><\/a><\/h3>$/;"	a
pdf-math.min	doc/manual.html	/^<hr><h3><a name="pdf-math.min"><code>math.min (x, &middot;&middot;&middot;)<\/code><\/a><\/h3>$/;"	a
pdf-math.modf	doc/manual.html	/^<hr><h3><a name="pdf-math.modf"><code>math.modf (x)<\/code><\/a><\/h3>$/;"	a
pdf-math.pi	doc/manual.html	/^<hr><h3><a name="pdf-math.pi"><code>math.pi<\/code><\/a><\/h3>$/;"	a
pdf-math.pow	doc/manual.html	/^<hr><h3><a name="pdf-math.pow"><code>math.pow (x, y)<\/code><\/a><\/h3>$/;"	a
pdf-math.rad	doc/manual.html	/^<hr><h3><a name="pdf-math.rad"><code>math.rad (x)<\/code><\/a><\/h3>$/;"	a
pdf-math.random	doc/manual.html	/^<hr><h3><a name="pdf-math.random"><code>math.random ([m [, n]])<\/code><\/a><\/h3>$/;"	a
pdf-math.randomseed	doc/manual.html	/^<hr><h3><a name="pdf-math.randomseed"><code>math.randomseed (x)<\/code><\/a><\/h3>$/;"	a
pdf-math.sin	doc/manual.html	/^<hr><h3><a name="pdf-math.sin"><code>math.sin (x)<\/code><\/a><\/h3>$/;"	a
pdf-math.sinh	doc/manual.html	/^<hr><h3><a name="pdf-math.sinh"><code>math.sinh (x)<\/code><\/a><\/h3>$/;"	a
pdf-math.sqrt	doc/manual.html	/^<hr><h3><a name="pdf-math.sqrt"><code>math.sqrt (x)<\/code><\/a><\/h3>$/;"	a
pdf-math.tan	doc/manual.html	/^<hr><h3><a name="pdf-math.tan"><code>math.tan (x)<\/code><\/a><\/h3>$/;"	a
pdf-math.tanh	doc/manual.html	/^<hr><h3><a name="pdf-math.tanh"><code>math.tanh (x)<\/code><\/a><\/h3>$/;"	a
pdf-module	doc/manual.html	/^<hr><h3><a name="pdf-module"><code>module (name [, &middot;&middot;&middot;])<\/code><\/a><\/h3>$/;"	a
pdf-next	doc/manual.html	/^<hr><h3><a name="pdf-next"><code>next (table [, index])<\/code><\/a><\/h3>$/;"	a
pdf-os	doc/manual.html	/^This library is implemented through table <a name="pdf-os"><code>os<\/code><\/a>.$/;"	a
pdf-os.clock	doc/manual.html	/^<hr><h3><a name="pdf-os.clock"><code>os.clock ()<\/code><\/a><\/h3>$/;"	a
pdf-os.date	doc/manual.html	/^<hr><h3><a name="pdf-os.date"><code>os.date ([format [, time]])<\/code><\/a><\/h3>$/;"	a
pdf-os.difftime	doc/manual.html	/^<hr><h3><a name="pdf-os.difftime"><code>os.difftime (t2, t1)<\/code><\/a><\/h3>$/;"	a
pdf-os.execute	doc/manual.html	/^<hr><h3><a name="pdf-os.execute"><code>os.execute ([command])<\/code><\/a><\/h3>$/;"	a
pdf-os.exit	doc/manual.html	/^<hr><h3><a name="pdf-os.exit"><code>os.exit ([code])<\/code><\/a><\/h3>$/;"	a
pdf-os.getenv	doc/manual.html	/^<hr><h3><a name="pdf-os.getenv"><code>os.getenv (varname)<\/code><\/a><\/h3>$/;"	a
pdf-os.remove	doc/manual.html	/^<hr><h3><a name="pdf-os.remove"><code>os.remove (filename)<\/code><\/a><\/h3>$/;"	a
pdf-os.rename	doc/manual.html	/^<hr><h3><a name="pdf-os.rename"><code>os.rename (oldname, newname)<\/code><\/a><\/h3>$/;"	a
pdf-os.setlocale	doc/manual.html	/^<hr><h3><a name="pdf-os.setlocale"><code>os.setlocale (locale [, category])<\/code><\/a><\/h3>$/;"	a
pdf-os.time	doc/manual.html	/^<hr><h3><a name="pdf-os.time"><code>os.time ([table])<\/code><\/a><\/h3>$/;"	a
pdf-os.tmpname	doc/manual.html	/^<hr><h3><a name="pdf-os.tmpname"><code>os.tmpname ()<\/code><\/a><\/h3>$/;"	a
pdf-package	doc/manual.html	/^Everything else is exported in a table <a name="pdf-package"><code>package<\/code><\/a>.$/;"	a
pdf-package.cpath	doc/manual.html	/^<hr><h3><a name="pdf-package.cpath"><code>package.cpath<\/code><\/a><\/h3>$/;"	a
pdf-package.loaded	doc/manual.html	/^<hr><h3><a name="pdf-package.loaded"><code>package.loaded<\/code><\/a><\/h3>$/;"	a
pdf-package.loaders	doc/manual.html	/^<hr><h3><a name="pdf-package.loaders"><code>package.loaders<\/code><\/a><\/h3>$/;"	a
pdf-package.loadlib	doc/manual.html	/^<hr><h3><a name="pdf-package.loadlib"><code>package.loadlib (libname, funcname)<\/code><\/a><\/h3>$/;"	a
pdf-package.path	doc/manual.html	/^<hr><h3><a name="pdf-package.path"><code>package.path<\/code><\/a><\/h3>$/;"	a
pdf-package.preload	doc/manual.html	/^<hr><h3><a name="pdf-package.preload"><code>package.preload<\/code><\/a><\/h3>$/;"	a
pdf-package.seeall	doc/manual.html	/^<hr><h3><a name="pdf-package.seeall"><code>package.seeall (module)<\/code><\/a><\/h3>$/;"	a
pdf-pairs	doc/manual.html	/^<hr><h3><a name="pdf-pairs"><code>pairs (t)<\/code><\/a><\/h3>$/;"	a
pdf-pcall	doc/manual.html	/^<hr><h3><a name="pdf-pcall"><code>pcall (f, arg1, &middot;&middot;&middot;)<\/code><\/a><\/h3>$/;"	a
pdf-print	doc/manual.html	/^<hr><h3><a name="pdf-print"><code>print (&middot;&middot;&middot;)<\/code><\/a><\/h3>$/;"	a
pdf-rawequal	doc/manual.html	/^<hr><h3><a name="pdf-rawequal"><code>rawequal (v1, v2)<\/code><\/a><\/h3>$/;"	a
pdf-rawget	doc/manual.html	/^<hr><h3><a name="pdf-rawget"><code>rawget (table, index)<\/code><\/a><\/h3>$/;"	a
pdf-rawset	doc/manual.html	/^<hr><h3><a name="pdf-rawset"><code>rawset (table, index, value)<\/code><\/a><\/h3>$/;"	a
pdf-require	doc/manual.html	/^<hr><h3><a name="pdf-require"><code>require (modname)<\/code><\/a><\/h3>$/;"	a
pdf-select	doc/manual.html	/^<hr><h3><a name="pdf-select"><code>select (index, &middot;&middot;&middot;)<\/code><\/a><\/h3>$/;"	a
pdf-setfenv	doc/manual.html	/^<hr><h3><a name="pdf-setfenv"><code>setfenv (f, table)<\/code><\/a><\/h3>$/;"	a
pdf-setmetatable	doc/manual.html	/^<hr><h3><a name="pdf-setmetatable"><code>setmetatable (table, metatable)<\/code><\/a><\/h3>$/;"	a
pdf-string	doc/manual.html	/^<a name="pdf-string"><code>string<\/code><\/a>.$/;"	a
pdf-string.byte	doc/manual.html	/^<hr><h3><a name="pdf-string.byte"><code>string.byte (s [, i [, j]])<\/code><\/a><\/h3>$/;"	a
pdf-string.char	doc/manual.html	/^<hr><h3><a name="pdf-string.char"><code>string.char (&middot;&middot;&middot;)<\/code><\/a><\/h3>$/;"	a
pdf-string.dump	doc/manual.html	/^<hr><h3><a name="pdf-string.dump"><code>string.dump (function)<\/code><\/a><\/h3>$/;"	a
pdf-string.find	doc/manual.html	/^<hr><h3><a name="pdf-string.find"><code>string.find (s, pattern [, init [, plain]])<\/code><\/a><\/h3>$/;"	a
pdf-string.format	doc/manual.html	/^<hr><h3><a name="pdf-string.format"><code>string.format (formatstring, &middot;&middot;&middot;)<\/code><\/a><\/h3>$/;"	a
pdf-string.gmatch	doc/manual.html	/^<hr><h3><a name="pdf-string.gmatch"><code>string.gmatch (s, pattern)<\/code><\/a><\/h3>$/;"	a
pdf-string.gsub	doc/manual.html	/^<hr><h3><a name="pdf-string.gsub"><code>string.gsub (s, pattern, repl [, n])<\/code><\/a><\/h3>$/;"	a
pdf-string.len	doc/manual.html	/^<hr><h3><a name="pdf-string.len"><code>string.len (s)<\/code><\/a><\/h3>$/;"	a
pdf-string.lower	doc/manual.html	/^<hr><h3><a name="pdf-string.lower"><code>string.lower (s)<\/code><\/a><\/h3>$/;"	a
pdf-string.match	doc/manual.html	/^<hr><h3><a name="pdf-string.match"><code>string.match (s, pattern [, init])<\/code><\/a><\/h3>$/;"	a
pdf-string.rep	doc/manual.html	/^<hr><h3><a name="pdf-string.rep"><code>string.rep (s, n)<\/code><\/a><\/h3>$/;"	a
pdf-string.reverse	doc/manual.html	/^<hr><h3><a name="pdf-string.reverse"><code>string.reverse (s)<\/code><\/a><\/h3>$/;"	a
pdf-string.sub	doc/manual.html	/^<hr><h3><a name="pdf-string.sub"><code>string.sub (s, i [, j])<\/code><\/a><\/h3>$/;"	a
pdf-string.upper	doc/manual.html	/^<hr><h3><a name="pdf-string.upper"><code>string.upper (s)<\/code><\/a><\/h3>$/;"	a
pdf-table	doc/manual.html	/^It provides all its functions inside the table <a name="pdf-table"><code>table<\/code><\/a>.$/;"	a
pdf-table.concat	doc/manual.html	/^<hr><h3><a name="pdf-table.concat"><code>table.concat (table [, sep [, i [, j]]])<\/code><\/a><\/h3>$/;"	a
pdf-table.insert	doc/manual.html	/^<hr><h3><a name="pdf-table.insert"><code>table.insert (table, [pos,] value)<\/code><\/a><\/h3>$/;"	a
pdf-table.maxn	doc/manual.html	/^<hr><h3><a name="pdf-table.maxn"><code>table.maxn (table)<\/code><\/a><\/h3>$/;"	a
pdf-table.remove	doc/manual.html	/^<hr><h3><a name="pdf-table.remove"><code>table.remove (table [, pos])<\/code><\/a><\/h3>$/;"	a
pdf-table.sort	doc/manual.html	/^<hr><h3><a name="pdf-table.sort"><code>table.sort (table [, comp])<\/code><\/a><\/h3>$/;"	a
pdf-tonumber	doc/manual.html	/^<hr><h3><a name="pdf-tonumber"><code>tonumber (e [, base])<\/code><\/a><\/h3>$/;"	a
pdf-tostring	doc/manual.html	/^<hr><h3><a name="pdf-tostring"><code>tostring (e)<\/code><\/a><\/h3>$/;"	a
pdf-type	doc/manual.html	/^<hr><h3><a name="pdf-type"><code>type (v)<\/code><\/a><\/h3>$/;"	a
pdf-unpack	doc/manual.html	/^<hr><h3><a name="pdf-unpack"><code>unpack (list [, i [, j]])<\/code><\/a><\/h3>$/;"	a
pdf-xpcall	doc/manual.html	/^<hr><h3><a name="pdf-xpcall"><code>xpcall (f, err)<\/code><\/a><\/h3>$/;"	a
r	doc/manual.html	/^     function r() return 1,2,3 end$/;"	f
settable_event	doc/manual.html	/^     function settable_event (table, key, value)$/;"	f
unm_event	doc/manual.html	/^     function unm_event (op)$/;"	f
BIN	etc/Makefile	/^BIN= $(TOP)\/src$/;"	m
CC	etc/Makefile	/^CC= gcc$/;"	m
CFLAGS	etc/Makefile	/^CFLAGS= -O2 -Wall -I$(INC) $(MYCFLAGS)$/;"	m
INC	etc/Makefile	/^INC= $(TOP)\/src$/;"	m
LIB	etc/Makefile	/^LIB= $(TOP)\/src$/;"	m
MYCFLAGS	etc/Makefile	/^MYCFLAGS= $/;"	m
MYLDFLAGS	etc/Makefile	/^MYLDFLAGS= -Wl,-E$/;"	m
MYLIBS	etc/Makefile	/^MYLIBS= -lm$/;"	m
RM	etc/Makefile	/^RM= rm -f$/;"	m
SRC	etc/Makefile	/^SRC= $(TOP)\/src$/;"	m
TOP	etc/Makefile	/^TOP= ..$/;"	m
TST	etc/Makefile	/^TST= $(TOP)\/test$/;"	m
a	etc/Makefile	/^	-.\/a.out -e'a=1'$/;"	m
luaall_c	etc/all.c	/^#define luaall_c$/;"	d	file:
MYCOMPILE	etc/luavs.bat	/^@set MYCOMPILE=cl \/nologo \/MD \/O2 \/W3 \/c \/D_CRT_SECURE_NO_DEPRECATE$/;"	v
MYLINK	etc/luavs.bat	/^@set MYLINK=link \/nologo$/;"	v
MYMT	etc/luavs.bat	/^@set MYMT=mt \/nologo$/;"	v
main	etc/min.c	/^int main(void)$/;"	f
print	etc/min.c	/^static int print(lua_State *L)$/;"	f	file:
LUA_CORE	etc/noparser.c	/^#define LUA_CORE$/;"	d	file:
luaU_dump	etc/noparser.c	/^LUAI_FUNC int luaU_dump (lua_State* L, const Proto* f, lua_Writer w, void* data, int strip) {$/;"	f
luaX_init	etc/noparser.c	/^LUAI_FUNC void luaX_init (lua_State *L) {$/;"	f
luaY_parser	etc/noparser.c	/^LUAI_FUNC Proto *luaY_parser (lua_State *L, ZIO *z, Mbuffer *buff, const char *name) {$/;"	f
mt.__index 	etc/strict.lua	/^mt.__index = function (t, n)$/;"	f
mt.__newindex 	etc/strict.lua	/^mt.__newindex = function (t, n, v)$/;"	f
what 	etc/strict.lua	/^local function what ()$/;"	f
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
ALL_A	src/Makefile	/^ALL_A= $(LUA_A)$/;"	m
ALL_O	src/Makefile	/^ALL_O= $(CORE_O) $(LIB_O) $(LUA_O) $(LUAC_O)$/;"	m
ALL_T	src/Makefile	/^ALL_T= $(LUA_A) $(LUA_T) $(LUAC_T)$/;"	m
AR	src/Makefile	/^AR= ar rcu$/;"	m
CC	src/Makefile	/^CC= gcc$/;"	m
CFLAGS	src/Makefile	/^CFLAGS= -O2 -Wall $(MYCFLAGS)$/;"	m
CORE_O	src/Makefile	/^CORE_O=	lapi.o lcode.o ldebug.o ldo.o ldump.o lfunc.o lgc.o llex.o lmem.o \\$/;"	m
LIBS	src/Makefile	/^LIBS= -lm $(MYLIBS)$/;"	m
LIB_O	src/Makefile	/^LIB_O=	lauxlib.o lbaselib.o ldblib.o liolib.o lmathlib.o loslib.o ltablib.o \\$/;"	m
LUAC_O	src/Makefile	/^LUAC_O=	luac.o print.o$/;"	m
LUAC_T	src/Makefile	/^LUAC_T=	luac$/;"	m
LUA_A	src/Makefile	/^LUA_A=	liblua.a$/;"	m
LUA_O	src/Makefile	/^LUA_O=	lua.o$/;"	m
LUA_T	src/Makefile	/^LUA_T=	lua$/;"	m
MYCFLAGS	src/Makefile	/^MYCFLAGS=$/;"	m
MYLDFLAGS	src/Makefile	/^MYLDFLAGS=$/;"	m
MYLIBS	src/Makefile	/^MYLIBS=$/;"	m
PLAT	src/Makefile	/^PLAT= none$/;"	m
PLATS	src/Makefile	/^PLATS= aix ansi bsd freebsd generic linux macosx mingw posix solaris$/;"	m
RANLIB	src/Makefile	/^RANLIB= ranlib$/;"	m
RM	src/Makefile	/^RM= rm -f$/;"	m
CCallS	src/lapi.c	/^struct CCallS {  \/* data to `f_Ccall' *\/$/;"	s	file:
CallS	src/lapi.c	/^struct CallS {  \/* data to `f_call' *\/$/;"	s	file:
LUA_CORE	src/lapi.c	/^#define LUA_CORE$/;"	d	file:
adjustresults	src/lapi.c	/^#define adjustresults(/;"	d	file:
api_checknelems	src/lapi.c	/^#define api_checknelems(/;"	d	file:
api_checkvalidindex	src/lapi.c	/^#define api_checkvalidindex(/;"	d	file:
api_incr_top	src/lapi.c	/^#define api_incr_top(/;"	d	file:
aux_upvalue	src/lapi.c	/^static const char *aux_upvalue (StkId fi, int n, TValue **val) {$/;"	f	file:
checkresults	src/lapi.c	/^#define checkresults(/;"	d	file:
f_Ccall	src/lapi.c	/^static void f_Ccall (lua_State *L, void *ud) {$/;"	f	file:
f_call	src/lapi.c	/^static void f_call (lua_State *L, void *ud) {$/;"	f	file:
func	src/lapi.c	/^  StkId func;$/;"	m	struct:CallS	file:
func	src/lapi.c	/^  lua_CFunction func;$/;"	m	struct:CCallS	file:
getcurrenv	src/lapi.c	/^static Table *getcurrenv (lua_State *L) {$/;"	f	file:
index2adr	src/lapi.c	/^static TValue *index2adr (lua_State *L, int idx) {$/;"	f	file:
lapi_c	src/lapi.c	/^#define lapi_c$/;"	d	file:
luaA_pushobject	src/lapi.c	/^void luaA_pushobject (lua_State *L, const TValue *o) {$/;"	f
lua_atpanic	src/lapi.c	/^LUA_API lua_CFunction lua_atpanic (lua_State *L, lua_CFunction panicf) {$/;"	f
lua_call	src/lapi.c	/^LUA_API void lua_call (lua_State *L, int nargs, int nresults) {$/;"	f
lua_checkstack	src/lapi.c	/^LUA_API int lua_checkstack (lua_State *L, int size) {$/;"	f
lua_concat	src/lapi.c	/^LUA_API void lua_concat (lua_State *L, int n) {$/;"	f
lua_cpcall	src/lapi.c	/^LUA_API int lua_cpcall (lua_State *L, lua_CFunction func, void *ud) {$/;"	f
lua_createtable	src/lapi.c	/^LUA_API void lua_createtable (lua_State *L, int narray, int nrec) {$/;"	f
lua_dump	src/lapi.c	/^LUA_API int lua_dump (lua_State *L, lua_Writer writer, void *data) {$/;"	f
lua_equal	src/lapi.c	/^LUA_API int lua_equal (lua_State *L, int index1, int index2) {$/;"	f
lua_error	src/lapi.c	/^LUA_API int lua_error (lua_State *L) {$/;"	f
lua_gc	src/lapi.c	/^LUA_API int lua_gc (lua_State *L, int what, int data) {$/;"	f
lua_getallocf	src/lapi.c	/^LUA_API lua_Alloc lua_getallocf (lua_State *L, void **ud) {$/;"	f
lua_getfenv	src/lapi.c	/^LUA_API void lua_getfenv (lua_State *L, int idx) {$/;"	f
lua_getfield	src/lapi.c	/^LUA_API void lua_getfield (lua_State *L, int idx, const char *k) {$/;"	f
lua_getmetatable	src/lapi.c	/^LUA_API int lua_getmetatable (lua_State *L, int objindex) {$/;"	f
lua_gettable	src/lapi.c	/^LUA_API void lua_gettable (lua_State *L, int idx) {$/;"	f
lua_gettop	src/lapi.c	/^LUA_API int lua_gettop (lua_State *L) {$/;"	f
lua_getupvalue	src/lapi.c	/^LUA_API const char *lua_getupvalue (lua_State *L, int funcindex, int n) {$/;"	f
lua_ident	src/lapi.c	/^const char lua_ident[] =$/;"	v
lua_insert	src/lapi.c	/^LUA_API void lua_insert (lua_State *L, int idx) {$/;"	f
lua_iscfunction	src/lapi.c	/^LUA_API int lua_iscfunction (lua_State *L, int idx) {$/;"	f
lua_isnumber	src/lapi.c	/^LUA_API int lua_isnumber (lua_State *L, int idx) {$/;"	f
lua_isstring	src/lapi.c	/^LUA_API int lua_isstring (lua_State *L, int idx) {$/;"	f
lua_isuserdata	src/lapi.c	/^LUA_API int lua_isuserdata (lua_State *L, int idx) {$/;"	f
lua_lessthan	src/lapi.c	/^LUA_API int lua_lessthan (lua_State *L, int index1, int index2) {$/;"	f
lua_load	src/lapi.c	/^LUA_API int lua_load (lua_State *L, lua_Reader reader, void *data,$/;"	f
lua_newthread	src/lapi.c	/^LUA_API lua_State *lua_newthread (lua_State *L) {$/;"	f
lua_newuserdata	src/lapi.c	/^LUA_API void *lua_newuserdata (lua_State *L, size_t size) {$/;"	f
lua_next	src/lapi.c	/^LUA_API int lua_next (lua_State *L, int idx) {$/;"	f
lua_objlen	src/lapi.c	/^LUA_API size_t lua_objlen (lua_State *L, int idx) {$/;"	f
lua_pcall	src/lapi.c	/^LUA_API int lua_pcall (lua_State *L, int nargs, int nresults, int errfunc) {$/;"	f
lua_pushboolean	src/lapi.c	/^LUA_API void lua_pushboolean (lua_State *L, int b) {$/;"	f
lua_pushcclosure	src/lapi.c	/^LUA_API void lua_pushcclosure (lua_State *L, lua_CFunction fn, int n) {$/;"	f
lua_pushfstring	src/lapi.c	/^LUA_API const char *lua_pushfstring (lua_State *L, const char *fmt, ...) {$/;"	f
lua_pushinteger	src/lapi.c	/^LUA_API void lua_pushinteger (lua_State *L, lua_Integer n) {$/;"	f
lua_pushlightuserdata	src/lapi.c	/^LUA_API void lua_pushlightuserdata (lua_State *L, void *p) {$/;"	f
lua_pushlstring	src/lapi.c	/^LUA_API void lua_pushlstring (lua_State *L, const char *s, size_t len) {$/;"	f
lua_pushnil	src/lapi.c	/^LUA_API void lua_pushnil (lua_State *L) {$/;"	f
lua_pushnumber	src/lapi.c	/^LUA_API void lua_pushnumber (lua_State *L, lua_Number n) {$/;"	f
lua_pushstring	src/lapi.c	/^LUA_API void lua_pushstring (lua_State *L, const char *s) {$/;"	f
lua_pushthread	src/lapi.c	/^LUA_API int lua_pushthread (lua_State *L) {$/;"	f
lua_pushvalue	src/lapi.c	/^LUA_API void lua_pushvalue (lua_State *L, int idx) {$/;"	f
lua_pushvfstring	src/lapi.c	/^LUA_API const char *lua_pushvfstring (lua_State *L, const char *fmt,$/;"	f
lua_rawequal	src/lapi.c	/^LUA_API int lua_rawequal (lua_State *L, int index1, int index2) {$/;"	f
lua_rawget	src/lapi.c	/^LUA_API void lua_rawget (lua_State *L, int idx) {$/;"	f
lua_rawgeti	src/lapi.c	/^LUA_API void lua_rawgeti (lua_State *L, int idx, int n) {$/;"	f
lua_rawset	src/lapi.c	/^LUA_API void lua_rawset (lua_State *L, int idx) {$/;"	f
lua_rawseti	src/lapi.c	/^LUA_API void lua_rawseti (lua_State *L, int idx, int n) {$/;"	f
lua_remove	src/lapi.c	/^LUA_API void lua_remove (lua_State *L, int idx) {$/;"	f
lua_replace	src/lapi.c	/^LUA_API void lua_replace (lua_State *L, int idx) {$/;"	f
lua_setallocf	src/lapi.c	/^LUA_API void lua_setallocf (lua_State *L, lua_Alloc f, void *ud) {$/;"	f
lua_setfenv	src/lapi.c	/^LUA_API int lua_setfenv (lua_State *L, int idx) {$/;"	f
lua_setfield	src/lapi.c	/^LUA_API void lua_setfield (lua_State *L, int idx, const char *k) {$/;"	f
lua_setlevel	src/lapi.c	/^LUA_API void lua_setlevel (lua_State *from, lua_State *to) {$/;"	f
lua_setmetatable	src/lapi.c	/^LUA_API int lua_setmetatable (lua_State *L, int objindex) {$/;"	f
lua_settable	src/lapi.c	/^LUA_API void lua_settable (lua_State *L, int idx) {$/;"	f
lua_settop	src/lapi.c	/^LUA_API void lua_settop (lua_State *L, int idx) {$/;"	f
lua_setupvalue	src/lapi.c	/^LUA_API const char *lua_setupvalue (lua_State *L, int funcindex, int n) {$/;"	f
lua_status	src/lapi.c	/^LUA_API int  lua_status (lua_State *L) {$/;"	f
lua_toboolean	src/lapi.c	/^LUA_API int lua_toboolean (lua_State *L, int idx) {$/;"	f
lua_tocfunction	src/lapi.c	/^LUA_API lua_CFunction lua_tocfunction (lua_State *L, int idx) {$/;"	f
lua_tointeger	src/lapi.c	/^LUA_API lua_Integer lua_tointeger (lua_State *L, int idx) {$/;"	f
lua_tolstring	src/lapi.c	/^LUA_API const char *lua_tolstring (lua_State *L, int idx, size_t *len) {$/;"	f
lua_tonumber	src/lapi.c	/^LUA_API lua_Number lua_tonumber (lua_State *L, int idx) {$/;"	f
lua_topointer	src/lapi.c	/^LUA_API const void *lua_topointer (lua_State *L, int idx) {$/;"	f
lua_tothread	src/lapi.c	/^LUA_API lua_State *lua_tothread (lua_State *L, int idx) {$/;"	f
lua_touserdata	src/lapi.c	/^LUA_API void *lua_touserdata (lua_State *L, int idx) {$/;"	f
lua_type	src/lapi.c	/^LUA_API int lua_type (lua_State *L, int idx) {$/;"	f
lua_typename	src/lapi.c	/^LUA_API const char *lua_typename (lua_State *L, int t) {$/;"	f
lua_xmove	src/lapi.c	/^LUA_API void lua_xmove (lua_State *from, lua_State *to, int n) {$/;"	f
nresults	src/lapi.c	/^  int nresults;$/;"	m	struct:CallS	file:
ud	src/lapi.c	/^  void *ud;$/;"	m	struct:CCallS	file:
lapi_h	src/lapi.h	/^#define lapi_h$/;"	d
FREELIST_REF	src/lauxlib.c	/^#define FREELIST_REF	/;"	d	file:
LIMIT	src/lauxlib.c	/^#define LIMIT	/;"	d	file:
LUA_LIB	src/lauxlib.c	/^#define LUA_LIB$/;"	d	file:
LoadF	src/lauxlib.c	/^typedef struct LoadF {$/;"	s	file:
LoadF	src/lauxlib.c	/^} LoadF;$/;"	t	typeref:struct:LoadF	file:
LoadS	src/lauxlib.c	/^typedef struct LoadS {$/;"	s	file:
LoadS	src/lauxlib.c	/^} LoadS;$/;"	t	typeref:struct:LoadS	file:
abs_index	src/lauxlib.c	/^#define abs_index(/;"	d	file:
adjuststack	src/lauxlib.c	/^static void adjuststack (luaL_Buffer *B) {$/;"	f	file:
buff	src/lauxlib.c	/^  char buff[LUAL_BUFFERSIZE];$/;"	m	struct:LoadF	file:
bufffree	src/lauxlib.c	/^#define bufffree(/;"	d	file:
bufflen	src/lauxlib.c	/^#define bufflen(/;"	d	file:
checkint	src/lauxlib.c	/^static int checkint (lua_State *L, int topop) {$/;"	f	file:
emptybuffer	src/lauxlib.c	/^static int emptybuffer (luaL_Buffer *B) {$/;"	f	file:
errfile	src/lauxlib.c	/^static int errfile (lua_State *L, const char *what, int fnameindex) {$/;"	f	file:
extraline	src/lauxlib.c	/^  int extraline;$/;"	m	struct:LoadF	file:
f	src/lauxlib.c	/^  FILE *f;$/;"	m	struct:LoadF	file:
getF	src/lauxlib.c	/^static const char *getF (lua_State *L, void *ud, size_t *size) {$/;"	f	file:
getS	src/lauxlib.c	/^static const char *getS (lua_State *L, void *ud, size_t *size) {$/;"	f	file:
getsizes	src/lauxlib.c	/^static void getsizes (lua_State *L) {$/;"	f	file:
l_alloc	src/lauxlib.c	/^static void *l_alloc (void *ud, void *ptr, size_t osize, size_t nsize) {$/;"	f	file:
lauxlib_c	src/lauxlib.c	/^#define lauxlib_c$/;"	d	file:
libsize	src/lauxlib.c	/^static int libsize (const luaL_Reg *l) {$/;"	f	file:
luaI_openlib	src/lauxlib.c	/^LUALIB_API void luaI_openlib (lua_State *L, const char *libname,$/;"	f
luaL_addlstring	src/lauxlib.c	/^LUALIB_API void luaL_addlstring (luaL_Buffer *B, const char *s, size_t l) {$/;"	f
luaL_addstring	src/lauxlib.c	/^LUALIB_API void luaL_addstring (luaL_Buffer *B, const char *s) {$/;"	f
luaL_addvalue	src/lauxlib.c	/^LUALIB_API void luaL_addvalue (luaL_Buffer *B) {$/;"	f
luaL_argerror	src/lauxlib.c	/^LUALIB_API int luaL_argerror (lua_State *L, int narg, const char *extramsg) {$/;"	f
luaL_buffinit	src/lauxlib.c	/^LUALIB_API void luaL_buffinit (lua_State *L, luaL_Buffer *B) {$/;"	f
luaL_callmeta	src/lauxlib.c	/^LUALIB_API int luaL_callmeta (lua_State *L, int obj, const char *event) {$/;"	f
luaL_checkany	src/lauxlib.c	/^LUALIB_API void luaL_checkany (lua_State *L, int narg) {$/;"	f
luaL_checkinteger	src/lauxlib.c	/^LUALIB_API lua_Integer luaL_checkinteger (lua_State *L, int narg) {$/;"	f
luaL_checklstring	src/lauxlib.c	/^LUALIB_API const char *luaL_checklstring (lua_State *L, int narg, size_t *len) {$/;"	f
luaL_checknumber	src/lauxlib.c	/^LUALIB_API lua_Number luaL_checknumber (lua_State *L, int narg) {$/;"	f
luaL_checkoption	src/lauxlib.c	/^LUALIB_API int luaL_checkoption (lua_State *L, int narg, const char *def,$/;"	f
luaL_checkstack	src/lauxlib.c	/^LUALIB_API void luaL_checkstack (lua_State *L, int space, const char *mes) {$/;"	f
luaL_checktype	src/lauxlib.c	/^LUALIB_API void luaL_checktype (lua_State *L, int narg, int t) {$/;"	f
luaL_checkudata	src/lauxlib.c	/^LUALIB_API void *luaL_checkudata (lua_State *L, int ud, const char *tname) {$/;"	f
luaL_error	src/lauxlib.c	/^LUALIB_API int luaL_error (lua_State *L, const char *fmt, ...) {$/;"	f
luaL_findtable	src/lauxlib.c	/^LUALIB_API const char *luaL_findtable (lua_State *L, int idx,$/;"	f
luaL_getmetafield	src/lauxlib.c	/^LUALIB_API int luaL_getmetafield (lua_State *L, int obj, const char *event) {$/;"	f
luaL_getn	src/lauxlib.c	/^LUALIB_API int luaL_getn (lua_State *L, int t) {$/;"	f
luaL_gsub	src/lauxlib.c	/^LUALIB_API const char *luaL_gsub (lua_State *L, const char *s, const char *p,$/;"	f
luaL_loadbuffer	src/lauxlib.c	/^LUALIB_API int luaL_loadbuffer (lua_State *L, const char *buff, size_t size,$/;"	f
luaL_loadfile	src/lauxlib.c	/^LUALIB_API int luaL_loadfile (lua_State *L, const char *filename) {$/;"	f
luaL_loadstring	src/lauxlib.c	/^LUALIB_API int (luaL_loadstring) (lua_State *L, const char *s) {$/;"	f
luaL_newmetatable	src/lauxlib.c	/^LUALIB_API int luaL_newmetatable (lua_State *L, const char *tname) {$/;"	f
luaL_newstate	src/lauxlib.c	/^LUALIB_API lua_State *luaL_newstate (void) {$/;"	f
luaL_optinteger	src/lauxlib.c	/^LUALIB_API lua_Integer luaL_optinteger (lua_State *L, int narg,$/;"	f
luaL_optlstring	src/lauxlib.c	/^LUALIB_API const char *luaL_optlstring (lua_State *L, int narg,$/;"	f
luaL_optnumber	src/lauxlib.c	/^LUALIB_API lua_Number luaL_optnumber (lua_State *L, int narg, lua_Number def) {$/;"	f
luaL_prepbuffer	src/lauxlib.c	/^LUALIB_API char *luaL_prepbuffer (luaL_Buffer *B) {$/;"	f
luaL_pushresult	src/lauxlib.c	/^LUALIB_API void luaL_pushresult (luaL_Buffer *B) {$/;"	f
luaL_ref	src/lauxlib.c	/^LUALIB_API int luaL_ref (lua_State *L, int t) {$/;"	f
luaL_register	src/lauxlib.c	/^LUALIB_API void (luaL_register) (lua_State *L, const char *libname,$/;"	f
luaL_setn	src/lauxlib.c	/^LUALIB_API void luaL_setn (lua_State *L, int t, int n) {$/;"	f
luaL_typerror	src/lauxlib.c	/^LUALIB_API int luaL_typerror (lua_State *L, int narg, const char *tname) {$/;"	f
luaL_unref	src/lauxlib.c	/^LUALIB_API void luaL_unref (lua_State *L, int t, int ref) {$/;"	f
luaL_where	src/lauxlib.c	/^LUALIB_API void luaL_where (lua_State *L, int level) {$/;"	f
panic	src/lauxlib.c	/^static int panic (lua_State *L) {$/;"	f	file:
s	src/lauxlib.c	/^  const char *s;$/;"	m	struct:LoadS	file:
size	src/lauxlib.c	/^  size_t size;$/;"	m	struct:LoadS	file:
tag_error	src/lauxlib.c	/^static void tag_error (lua_State *L, int narg, int tag) {$/;"	f	file:
L	src/lauxlib.h	/^  lua_State *L;$/;"	m	struct:luaL_Buffer
LUA_ERRFILE	src/lauxlib.h	/^#define LUA_ERRFILE /;"	d
LUA_NOREF	src/lauxlib.h	/^#define LUA_NOREF /;"	d
LUA_REFNIL	src/lauxlib.h	/^#define LUA_REFNIL /;"	d
buffer	src/lauxlib.h	/^  char buffer[LUAL_BUFFERSIZE];$/;"	m	struct:luaL_Buffer
func	src/lauxlib.h	/^  lua_CFunction func;$/;"	m	struct:luaL_Reg
lauxlib_h	src/lauxlib.h	/^#define lauxlib_h$/;"	d
luaI_openlib	src/lauxlib.h	/^#define luaI_openlib	/;"	d
luaL_Buffer	src/lauxlib.h	/^typedef struct luaL_Buffer {$/;"	s
luaL_Buffer	src/lauxlib.h	/^} luaL_Buffer;$/;"	t	typeref:struct:luaL_Buffer
luaL_Reg	src/lauxlib.h	/^typedef struct luaL_Reg {$/;"	s
luaL_Reg	src/lauxlib.h	/^} luaL_Reg;$/;"	t	typeref:struct:luaL_Reg
luaL_addchar	src/lauxlib.h	/^#define luaL_addchar(/;"	d
luaL_addsize	src/lauxlib.h	/^#define luaL_addsize(/;"	d
luaL_argcheck	src/lauxlib.h	/^#define luaL_argcheck(/;"	d
luaL_checkint	src/lauxlib.h	/^#define luaL_checkint(/;"	d
luaL_checklong	src/lauxlib.h	/^#define luaL_checklong(/;"	d
luaL_checkstring	src/lauxlib.h	/^#define luaL_checkstring(/;"	d
luaL_dofile	src/lauxlib.h	/^#define luaL_dofile(/;"	d
luaL_dostring	src/lauxlib.h	/^#define luaL_dostring(/;"	d
luaL_getmetatable	src/lauxlib.h	/^#define luaL_getmetatable(/;"	d
luaL_getn	src/lauxlib.h	/^#define luaL_getn(/;"	d
luaL_opt	src/lauxlib.h	/^#define luaL_opt(/;"	d
luaL_optint	src/lauxlib.h	/^#define luaL_optint(/;"	d
luaL_optlong	src/lauxlib.h	/^#define luaL_optlong(/;"	d
luaL_optstring	src/lauxlib.h	/^#define luaL_optstring(/;"	d
luaL_putchar	src/lauxlib.h	/^#define luaL_putchar(/;"	d
luaL_reg	src/lauxlib.h	/^#define luaL_reg	/;"	d
luaL_setn	src/lauxlib.h	/^#define luaL_setn(/;"	d
luaL_typename	src/lauxlib.h	/^#define luaL_typename(/;"	d
lua_getref	src/lauxlib.h	/^#define lua_getref(/;"	d
lua_ref	src/lauxlib.h	/^#define lua_ref(/;"	d
lua_unref	src/lauxlib.h	/^#define lua_unref(/;"	d
lvl	src/lauxlib.h	/^  int lvl;  \/* number of strings in the stack (level) *\/$/;"	m	struct:luaL_Buffer
name	src/lauxlib.h	/^  const char *name;$/;"	m	struct:luaL_Reg
p	src/lauxlib.h	/^  char *p;			\/* current position in buffer *\/$/;"	m	struct:luaL_Buffer
CO_DEAD	src/lbaselib.c	/^#define CO_DEAD	/;"	d	file:
CO_NOR	src/lbaselib.c	/^#define CO_NOR	/;"	d	file:
CO_RUN	src/lbaselib.c	/^#define CO_RUN	/;"	d	file:
CO_SUS	src/lbaselib.c	/^#define CO_SUS	/;"	d	file:
LUA_LIB	src/lbaselib.c	/^#define LUA_LIB$/;"	d	file:
auxopen	src/lbaselib.c	/^static void auxopen (lua_State *L, const char *name,$/;"	f	file:
auxresume	src/lbaselib.c	/^static int auxresume (lua_State *L, lua_State *co, int narg) {$/;"	f	file:
base_funcs	src/lbaselib.c	/^static const luaL_Reg base_funcs[] = {$/;"	v	file:
base_open	src/lbaselib.c	/^static void base_open (lua_State *L) {$/;"	f	file:
co_funcs	src/lbaselib.c	/^static const luaL_Reg co_funcs[] = {$/;"	v	file:
costatus	src/lbaselib.c	/^static int costatus (lua_State *L, lua_State *co) {$/;"	f	file:
generic_reader	src/lbaselib.c	/^static const char *generic_reader (lua_State *L, void *ud, size_t *size) {$/;"	f	file:
getfunc	src/lbaselib.c	/^static void getfunc (lua_State *L, int opt) {$/;"	f	file:
ipairsaux	src/lbaselib.c	/^static int ipairsaux (lua_State *L) {$/;"	f	file:
lbaselib_c	src/lbaselib.c	/^#define lbaselib_c$/;"	d	file:
load_aux	src/lbaselib.c	/^static int load_aux (lua_State *L, int status) {$/;"	f	file:
luaB_assert	src/lbaselib.c	/^static int luaB_assert (lua_State *L) {$/;"	f	file:
luaB_auxwrap	src/lbaselib.c	/^static int luaB_auxwrap (lua_State *L) {$/;"	f	file:
luaB_cocreate	src/lbaselib.c	/^static int luaB_cocreate (lua_State *L) {$/;"	f	file:
luaB_collectgarbage	src/lbaselib.c	/^static int luaB_collectgarbage (lua_State *L) {$/;"	f	file:
luaB_coresume	src/lbaselib.c	/^static int luaB_coresume (lua_State *L) {$/;"	f	file:
luaB_corunning	src/lbaselib.c	/^static int luaB_corunning (lua_State *L) {$/;"	f	file:
luaB_costatus	src/lbaselib.c	/^static int luaB_costatus (lua_State *L) {$/;"	f	file:
luaB_cowrap	src/lbaselib.c	/^static int luaB_cowrap (lua_State *L) {$/;"	f	file:
luaB_dofile	src/lbaselib.c	/^static int luaB_dofile (lua_State *L) {$/;"	f	file:
luaB_error	src/lbaselib.c	/^static int luaB_error (lua_State *L) {$/;"	f	file:
luaB_gcinfo	src/lbaselib.c	/^static int luaB_gcinfo (lua_State *L) {$/;"	f	file:
luaB_getfenv	src/lbaselib.c	/^static int luaB_getfenv (lua_State *L) {$/;"	f	file:
luaB_getmetatable	src/lbaselib.c	/^static int luaB_getmetatable (lua_State *L) {$/;"	f	file:
luaB_ipairs	src/lbaselib.c	/^static int luaB_ipairs (lua_State *L) {$/;"	f	file:
luaB_load	src/lbaselib.c	/^static int luaB_load (lua_State *L) {$/;"	f	file:
luaB_loadfile	src/lbaselib.c	/^static int luaB_loadfile (lua_State *L) {$/;"	f	file:
luaB_loadstring	src/lbaselib.c	/^static int luaB_loadstring (lua_State *L) {$/;"	f	file:
luaB_newproxy	src/lbaselib.c	/^static int luaB_newproxy (lua_State *L) {$/;"	f	file:
luaB_next	src/lbaselib.c	/^static int luaB_next (lua_State *L) {$/;"	f	file:
luaB_pairs	src/lbaselib.c	/^static int luaB_pairs (lua_State *L) {$/;"	f	file:
luaB_pcall	src/lbaselib.c	/^static int luaB_pcall (lua_State *L) {$/;"	f	file:
luaB_print	src/lbaselib.c	/^static int luaB_print (lua_State *L) {$/;"	f	file:
luaB_rawequal	src/lbaselib.c	/^static int luaB_rawequal (lua_State *L) {$/;"	f	file:
luaB_rawget	src/lbaselib.c	/^static int luaB_rawget (lua_State *L) {$/;"	f	file:
luaB_rawset	src/lbaselib.c	/^static int luaB_rawset (lua_State *L) {$/;"	f	file:
luaB_select	src/lbaselib.c	/^static int luaB_select (lua_State *L) {$/;"	f	file:
luaB_setfenv	src/lbaselib.c	/^static int luaB_setfenv (lua_State *L) {$/;"	f	file:
luaB_setmetatable	src/lbaselib.c	/^static int luaB_setmetatable (lua_State *L) {$/;"	f	file:
luaB_tonumber	src/lbaselib.c	/^static int luaB_tonumber (lua_State *L) {$/;"	f	file:
luaB_tostring	src/lbaselib.c	/^static int luaB_tostring (lua_State *L) {$/;"	f	file:
luaB_type	src/lbaselib.c	/^static int luaB_type (lua_State *L) {$/;"	f	file:
luaB_unpack	src/lbaselib.c	/^static int luaB_unpack (lua_State *L) {$/;"	f	file:
luaB_xpcall	src/lbaselib.c	/^static int luaB_xpcall (lua_State *L) {$/;"	f	file:
luaB_yield	src/lbaselib.c	/^static int luaB_yield (lua_State *L) {$/;"	f	file:
luaopen_base	src/lbaselib.c	/^LUALIB_API int luaopen_base (lua_State *L) {$/;"	f
statnames	src/lbaselib.c	/^static const char *const statnames[] =$/;"	v	file:
LUA_CORE	src/lcode.c	/^#define LUA_CORE$/;"	d	file:
addk	src/lcode.c	/^static int addk (FuncState *fs, TValue *k, TValue *v) {$/;"	f	file:
boolK	src/lcode.c	/^static int boolK (FuncState *fs, int b) {$/;"	f	file:
code_label	src/lcode.c	/^static int code_label (FuncState *fs, int A, int b, int jump) {$/;"	f	file:
codearith	src/lcode.c	/^static void codearith (FuncState *fs, OpCode op, expdesc *e1, expdesc *e2) {$/;"	f	file:
codecomp	src/lcode.c	/^static void codecomp (FuncState *fs, OpCode op, int cond, expdesc *e1,$/;"	f	file:
codenot	src/lcode.c	/^static void codenot (FuncState *fs, expdesc *e) {$/;"	f	file:
condjump	src/lcode.c	/^static int condjump (FuncState *fs, OpCode op, int A, int B, int C) {$/;"	f	file:
constfolding	src/lcode.c	/^static int constfolding (OpCode op, expdesc *e1, expdesc *e2) {$/;"	f	file:
discharge2anyreg	src/lcode.c	/^static void discharge2anyreg (FuncState *fs, expdesc *e) {$/;"	f	file:
discharge2reg	src/lcode.c	/^static void discharge2reg (FuncState *fs, expdesc *e, int reg) {$/;"	f	file:
dischargejpc	src/lcode.c	/^static void dischargejpc (FuncState *fs) {$/;"	f	file:
exp2reg	src/lcode.c	/^static void exp2reg (FuncState *fs, expdesc *e, int reg) {$/;"	f	file:
fixjump	src/lcode.c	/^static void fixjump (FuncState *fs, int pc, int dest) {$/;"	f	file:
freeexp	src/lcode.c	/^static void freeexp (FuncState *fs, expdesc *e) {$/;"	f	file:
freereg	src/lcode.c	/^static void freereg (FuncState *fs, int reg) {$/;"	f	file:
getjump	src/lcode.c	/^static int getjump (FuncState *fs, int pc) {$/;"	f	file:
getjumpcontrol	src/lcode.c	/^static Instruction *getjumpcontrol (FuncState *fs, int pc) {$/;"	f	file:
hasjumps	src/lcode.c	/^#define hasjumps(/;"	d	file:
invertjump	src/lcode.c	/^static void invertjump (FuncState *fs, expdesc *e) {$/;"	f	file:
isnumeral	src/lcode.c	/^static int isnumeral(expdesc *e) {$/;"	f	file:
jumponcond	src/lcode.c	/^static int jumponcond (FuncState *fs, expdesc *e, int cond) {$/;"	f	file:
lcode_c	src/lcode.c	/^#define lcode_c$/;"	d	file:
luaK_checkstack	src/lcode.c	/^void luaK_checkstack (FuncState *fs, int n) {$/;"	f
luaK_code	src/lcode.c	/^static int luaK_code (FuncState *fs, Instruction i, int line) {$/;"	f	file:
luaK_codeABC	src/lcode.c	/^int luaK_codeABC (FuncState *fs, OpCode o, int a, int b, int c) {$/;"	f
luaK_codeABx	src/lcode.c	/^int luaK_codeABx (FuncState *fs, OpCode o, int a, unsigned int bc) {$/;"	f
luaK_concat	src/lcode.c	/^void luaK_concat (FuncState *fs, int *l1, int l2) {$/;"	f
luaK_dischargevars	src/lcode.c	/^void luaK_dischargevars (FuncState *fs, expdesc *e) {$/;"	f
luaK_exp2RK	src/lcode.c	/^int luaK_exp2RK (FuncState *fs, expdesc *e) {$/;"	f
luaK_exp2anyreg	src/lcode.c	/^int luaK_exp2anyreg (FuncState *fs, expdesc *e) {$/;"	f
luaK_exp2nextreg	src/lcode.c	/^void luaK_exp2nextreg (FuncState *fs, expdesc *e) {$/;"	f
luaK_exp2val	src/lcode.c	/^void luaK_exp2val (FuncState *fs, expdesc *e) {$/;"	f
luaK_fixline	src/lcode.c	/^void luaK_fixline (FuncState *fs, int line) {$/;"	f
luaK_getlabel	src/lcode.c	/^int luaK_getlabel (FuncState *fs) {$/;"	f
luaK_goiffalse	src/lcode.c	/^static void luaK_goiffalse (FuncState *fs, expdesc *e) {$/;"	f	file:
luaK_goiftrue	src/lcode.c	/^void luaK_goiftrue (FuncState *fs, expdesc *e) {$/;"	f
luaK_indexed	src/lcode.c	/^void luaK_indexed (FuncState *fs, expdesc *t, expdesc *k) {$/;"	f
luaK_infix	src/lcode.c	/^void luaK_infix (FuncState *fs, BinOpr op, expdesc *v) {$/;"	f
luaK_jump	src/lcode.c	/^int luaK_jump (FuncState *fs) {$/;"	f
luaK_nil	src/lcode.c	/^void luaK_nil (FuncState *fs, int from, int n) {$/;"	f
luaK_numberK	src/lcode.c	/^int luaK_numberK (FuncState *fs, lua_Number r) {$/;"	f
luaK_patchlist	src/lcode.c	/^void luaK_patchlist (FuncState *fs, int list, int target) {$/;"	f
luaK_patchtohere	src/lcode.c	/^void luaK_patchtohere (FuncState *fs, int list) {$/;"	f
luaK_posfix	src/lcode.c	/^void luaK_posfix (FuncState *fs, BinOpr op, expdesc *e1, expdesc *e2) {$/;"	f
luaK_prefix	src/lcode.c	/^void luaK_prefix (FuncState *fs, UnOpr op, expdesc *e) {$/;"	f
luaK_reserveregs	src/lcode.c	/^void luaK_reserveregs (FuncState *fs, int n) {$/;"	f
luaK_ret	src/lcode.c	/^void luaK_ret (FuncState *fs, int first, int nret) {$/;"	f
luaK_self	src/lcode.c	/^void luaK_self (FuncState *fs, expdesc *e, expdesc *key) {$/;"	f
luaK_setlist	src/lcode.c	/^void luaK_setlist (FuncState *fs, int base, int nelems, int tostore) {$/;"	f
luaK_setoneret	src/lcode.c	/^void luaK_setoneret (FuncState *fs, expdesc *e) {$/;"	f
luaK_setreturns	src/lcode.c	/^void luaK_setreturns (FuncState *fs, expdesc *e, int nresults) {$/;"	f
luaK_storevar	src/lcode.c	/^void luaK_storevar (FuncState *fs, expdesc *var, expdesc *ex) {$/;"	f
luaK_stringK	src/lcode.c	/^int luaK_stringK (FuncState *fs, TString *s) {$/;"	f
need_value	src/lcode.c	/^static int need_value (FuncState *fs, int list) {$/;"	f	file:
nilK	src/lcode.c	/^static int nilK (FuncState *fs) {$/;"	f	file:
patchlistaux	src/lcode.c	/^static void patchlistaux (FuncState *fs, int list, int vtarget, int reg,$/;"	f	file:
patchtestreg	src/lcode.c	/^static int patchtestreg (FuncState *fs, int node, int reg) {$/;"	f	file:
removevalues	src/lcode.c	/^static void removevalues (FuncState *fs, int list) {$/;"	f	file:
BinOpr	src/lcode.h	/^typedef enum BinOpr {$/;"	g
BinOpr	src/lcode.h	/^} BinOpr;$/;"	t	typeref:enum:BinOpr
NO_JUMP	src/lcode.h	/^#define NO_JUMP /;"	d
OPR_ADD	src/lcode.h	/^  OPR_ADD, OPR_SUB, OPR_MUL, OPR_DIV, OPR_MOD, OPR_POW,$/;"	e	enum:BinOpr
OPR_AND	src/lcode.h	/^  OPR_AND, OPR_OR,$/;"	e	enum:BinOpr
OPR_CONCAT	src/lcode.h	/^  OPR_CONCAT,$/;"	e	enum:BinOpr
OPR_DIV	src/lcode.h	/^  OPR_ADD, OPR_SUB, OPR_MUL, OPR_DIV, OPR_MOD, OPR_POW,$/;"	e	enum:BinOpr
OPR_EQ	src/lcode.h	/^  OPR_NE, OPR_EQ,$/;"	e	enum:BinOpr
OPR_GE	src/lcode.h	/^  OPR_LT, OPR_LE, OPR_GT, OPR_GE,$/;"	e	enum:BinOpr
OPR_GT	src/lcode.h	/^  OPR_LT, OPR_LE, OPR_GT, OPR_GE,$/;"	e	enum:BinOpr
OPR_LE	src/lcode.h	/^  OPR_LT, OPR_LE, OPR_GT, OPR_GE,$/;"	e	enum:BinOpr
OPR_LEN	src/lcode.h	/^typedef enum UnOpr { OPR_MINUS, OPR_NOT, OPR_LEN, OPR_NOUNOPR } UnOpr;$/;"	e	enum:UnOpr
OPR_LT	src/lcode.h	/^  OPR_LT, OPR_LE, OPR_GT, OPR_GE,$/;"	e	enum:BinOpr
OPR_MINUS	src/lcode.h	/^typedef enum UnOpr { OPR_MINUS, OPR_NOT, OPR_LEN, OPR_NOUNOPR } UnOpr;$/;"	e	enum:UnOpr
OPR_MOD	src/lcode.h	/^  OPR_ADD, OPR_SUB, OPR_MUL, OPR_DIV, OPR_MOD, OPR_POW,$/;"	e	enum:BinOpr
OPR_MUL	src/lcode.h	/^  OPR_ADD, OPR_SUB, OPR_MUL, OPR_DIV, OPR_MOD, OPR_POW,$/;"	e	enum:BinOpr
OPR_NE	src/lcode.h	/^  OPR_NE, OPR_EQ,$/;"	e	enum:BinOpr
OPR_NOBINOPR	src/lcode.h	/^  OPR_NOBINOPR$/;"	e	enum:BinOpr
OPR_NOT	src/lcode.h	/^typedef enum UnOpr { OPR_MINUS, OPR_NOT, OPR_LEN, OPR_NOUNOPR } UnOpr;$/;"	e	enum:UnOpr
OPR_NOUNOPR	src/lcode.h	/^typedef enum UnOpr { OPR_MINUS, OPR_NOT, OPR_LEN, OPR_NOUNOPR } UnOpr;$/;"	e	enum:UnOpr
OPR_OR	src/lcode.h	/^  OPR_AND, OPR_OR,$/;"	e	enum:BinOpr
OPR_POW	src/lcode.h	/^  OPR_ADD, OPR_SUB, OPR_MUL, OPR_DIV, OPR_MOD, OPR_POW,$/;"	e	enum:BinOpr
OPR_SUB	src/lcode.h	/^  OPR_ADD, OPR_SUB, OPR_MUL, OPR_DIV, OPR_MOD, OPR_POW,$/;"	e	enum:BinOpr
UnOpr	src/lcode.h	/^typedef enum UnOpr { OPR_MINUS, OPR_NOT, OPR_LEN, OPR_NOUNOPR } UnOpr;$/;"	g
UnOpr	src/lcode.h	/^typedef enum UnOpr { OPR_MINUS, OPR_NOT, OPR_LEN, OPR_NOUNOPR } UnOpr;$/;"	t	typeref:enum:UnOpr
getcode	src/lcode.h	/^#define getcode(/;"	d
lcode_h	src/lcode.h	/^#define lcode_h$/;"	d
luaK_codeAsBx	src/lcode.h	/^#define luaK_codeAsBx(/;"	d
luaK_setmultret	src/lcode.h	/^#define luaK_setmultret(/;"	d
KEY_HOOK	src/ldblib.c	/^static const char KEY_HOOK = 'h';$/;"	v	file:
LEVELS1	src/ldblib.c	/^#define LEVELS1	/;"	d	file:
LEVELS2	src/ldblib.c	/^#define LEVELS2	/;"	d	file:
LUA_LIB	src/ldblib.c	/^#define LUA_LIB$/;"	d	file:
auxupvalue	src/ldblib.c	/^static int auxupvalue (lua_State *L, int get) {$/;"	f	file:
db_debug	src/ldblib.c	/^static int db_debug (lua_State *L) {$/;"	f	file:
db_errorfb	src/ldblib.c	/^static int db_errorfb (lua_State *L) {$/;"	f	file:
db_getfenv	src/ldblib.c	/^static int db_getfenv (lua_State *L) {$/;"	f	file:
db_gethook	src/ldblib.c	/^static int db_gethook (lua_State *L) {$/;"	f	file:
db_getinfo	src/ldblib.c	/^static int db_getinfo (lua_State *L) {$/;"	f	file:
db_getlocal	src/ldblib.c	/^static int db_getlocal (lua_State *L) {$/;"	f	file:
db_getmetatable	src/ldblib.c	/^static int db_getmetatable (lua_State *L) {$/;"	f	file:
db_getregistry	src/ldblib.c	/^static int db_getregistry (lua_State *L) {$/;"	f	file:
db_getupvalue	src/ldblib.c	/^static int db_getupvalue (lua_State *L) {$/;"	f	file:
db_setfenv	src/ldblib.c	/^static int db_setfenv (lua_State *L) {$/;"	f	file:
db_sethook	src/ldblib.c	/^static int db_sethook (lua_State *L) {$/;"	f	file:
db_setlocal	src/ldblib.c	/^static int db_setlocal (lua_State *L) {$/;"	f	file:
db_setmetatable	src/ldblib.c	/^static int db_setmetatable (lua_State *L) {$/;"	f	file:
db_setupvalue	src/ldblib.c	/^static int db_setupvalue (lua_State *L) {$/;"	f	file:
dblib	src/ldblib.c	/^static const luaL_Reg dblib[] = {$/;"	v	file:
gethooktable	src/ldblib.c	/^static void gethooktable (lua_State *L) {$/;"	f	file:
getthread	src/ldblib.c	/^static lua_State *getthread (lua_State *L, int *arg) {$/;"	f	file:
hookf	src/ldblib.c	/^static void hookf (lua_State *L, lua_Debug *ar) {$/;"	f	file:
ldblib_c	src/ldblib.c	/^#define ldblib_c$/;"	d	file:
luaopen_debug	src/ldblib.c	/^LUALIB_API int luaopen_debug (lua_State *L) {$/;"	f
makemask	src/ldblib.c	/^static int makemask (const char *smask, int count) {$/;"	f	file:
settabsi	src/ldblib.c	/^static void settabsi (lua_State *L, const char *i, int v) {$/;"	f	file:
settabss	src/ldblib.c	/^static void settabss (lua_State *L, const char *i, const char *v) {$/;"	f	file:
treatstackoption	src/ldblib.c	/^static void treatstackoption (lua_State *L, lua_State *L1, const char *fname) {$/;"	f	file:
unmakemask	src/ldblib.c	/^static char *unmakemask (int mask, char *smask) {$/;"	f	file:
LUA_CORE	src/ldebug.c	/^#define LUA_CORE$/;"	d	file:
addinfo	src/ldebug.c	/^static void addinfo (lua_State *L, const char *msg) {$/;"	f	file:
auxgetinfo	src/ldebug.c	/^static int auxgetinfo (lua_State *L, const char *what, lua_Debug *ar,$/;"	f	file:
check	src/ldebug.c	/^#define check(/;"	d	file:
check	src/ldebug.c	/^#undef check$/;"	d	file:
checkArgMode	src/ldebug.c	/^static int checkArgMode (const Proto *pt, int r, enum OpArgMask mode) {$/;"	f	file:
checkjump	src/ldebug.c	/^#define checkjump(/;"	d	file:
checkjump	src/ldebug.c	/^#undef checkjump$/;"	d	file:
checkopenop	src/ldebug.c	/^#define checkopenop(/;"	d	file:
checkreg	src/ldebug.c	/^#define checkreg(/;"	d	file:
checkreg	src/ldebug.c	/^#undef checkreg$/;"	d	file:
collectvalidlines	src/ldebug.c	/^static void collectvalidlines (lua_State *L, Closure *f) {$/;"	f	file:
currentline	src/ldebug.c	/^static int currentline (lua_State *L, CallInfo *ci) {$/;"	f	file:
currentpc	src/ldebug.c	/^static int currentpc (lua_State *L, CallInfo *ci) {$/;"	f	file:
findlocal	src/ldebug.c	/^static const char *findlocal (lua_State *L, CallInfo *ci, int n) {$/;"	f	file:
funcinfo	src/ldebug.c	/^static void funcinfo (lua_Debug *ar, Closure *cl) {$/;"	f	file:
getfuncname	src/ldebug.c	/^static const char *getfuncname (lua_State *L, CallInfo *ci, const char **name) {$/;"	f	file:
getluaproto	src/ldebug.c	/^static Proto *getluaproto (CallInfo *ci) {$/;"	f	file:
getobjname	src/ldebug.c	/^static const char *getobjname (lua_State *L, CallInfo *ci, int stackpos,$/;"	f	file:
info_tailcall	src/ldebug.c	/^static void info_tailcall (lua_Debug *ar) {$/;"	f	file:
isinstack	src/ldebug.c	/^static int isinstack (CallInfo *ci, const TValue *o) {$/;"	f	file:
kname	src/ldebug.c	/^static const char *kname (Proto *p, int c) {$/;"	f	file:
ldebug_c	src/ldebug.c	/^#define ldebug_c$/;"	d	file:
luaG_aritherror	src/ldebug.c	/^void luaG_aritherror (lua_State *L, const TValue *p1, const TValue *p2) {$/;"	f
luaG_checkcode	src/ldebug.c	/^int luaG_checkcode (const Proto *pt) {$/;"	f
luaG_checkopenop	src/ldebug.c	/^int luaG_checkopenop (Instruction i) {$/;"	f
luaG_concaterror	src/ldebug.c	/^void luaG_concaterror (lua_State *L, StkId p1, StkId p2) {$/;"	f
luaG_errormsg	src/ldebug.c	/^void luaG_errormsg (lua_State *L) {$/;"	f
luaG_ordererror	src/ldebug.c	/^int luaG_ordererror (lua_State *L, const TValue *p1, const TValue *p2) {$/;"	f
luaG_runerror	src/ldebug.c	/^void luaG_runerror (lua_State *L, const char *fmt, ...) {$/;"	f
luaG_typeerror	src/ldebug.c	/^void luaG_typeerror (lua_State *L, const TValue *o, const char *op) {$/;"	f
lua_gethook	src/ldebug.c	/^LUA_API lua_Hook lua_gethook (lua_State *L) {$/;"	f
lua_gethookcount	src/ldebug.c	/^LUA_API int lua_gethookcount (lua_State *L) {$/;"	f
lua_gethookmask	src/ldebug.c	/^LUA_API int lua_gethookmask (lua_State *L) {$/;"	f
lua_getinfo	src/ldebug.c	/^LUA_API int lua_getinfo (lua_State *L, const char *what, lua_Debug *ar) {$/;"	f
lua_getlocal	src/ldebug.c	/^LUA_API const char *lua_getlocal (lua_State *L, const lua_Debug *ar, int n) {$/;"	f
lua_getstack	src/ldebug.c	/^LUA_API int lua_getstack (lua_State *L, int level, lua_Debug *ar) {$/;"	f
lua_sethook	src/ldebug.c	/^LUA_API int lua_sethook (lua_State *L, lua_Hook func, int mask, int count) {$/;"	f
lua_setlocal	src/ldebug.c	/^LUA_API const char *lua_setlocal (lua_State *L, const lua_Debug *ar, int n) {$/;"	f
precheck	src/ldebug.c	/^static int precheck (const Proto *pt) {$/;"	f	file:
symbexec	src/ldebug.c	/^static Instruction symbexec (const Proto *pt, int lastpc, int reg) {$/;"	f	file:
getline	src/ldebug.h	/^#define getline(/;"	d
ldebug_h	src/ldebug.h	/^#define ldebug_h$/;"	d
pcRel	src/ldebug.h	/^#define pcRel(/;"	d
resethookcount	src/ldebug.h	/^#define resethookcount(/;"	d
LUA_CORE	src/ldo.c	/^#define LUA_CORE$/;"	d	file:
SParser	src/ldo.c	/^struct SParser {  \/* data to `f_parser' *\/$/;"	s	file:
adjust_varargs	src/ldo.c	/^static StkId adjust_varargs (lua_State *L, Proto *p, int actual) {$/;"	f	file:
b	src/ldo.c	/^  luai_jmpbuf b;$/;"	m	struct:lua_longjmp	file:
buff	src/ldo.c	/^  Mbuffer buff;  \/* buffer to be used by the scanner *\/$/;"	m	struct:SParser	file:
callrethooks	src/ldo.c	/^static StkId callrethooks (lua_State *L, StkId firstResult) {$/;"	f	file:
correctstack	src/ldo.c	/^static void correctstack (lua_State *L, TValue *oldstack) {$/;"	f	file:
f_parser	src/ldo.c	/^static void f_parser (lua_State *L, void *ud) {$/;"	f	file:
growCI	src/ldo.c	/^static CallInfo *growCI (lua_State *L) {$/;"	f	file:
inc_ci	src/ldo.c	/^#define inc_ci(/;"	d	file:
ldo_c	src/ldo.c	/^#define ldo_c$/;"	d	file:
luaD_call	src/ldo.c	/^void luaD_call (lua_State *L, StkId func, int nResults) {$/;"	f
luaD_callhook	src/ldo.c	/^void luaD_callhook (lua_State *L, int event, int line) {$/;"	f
luaD_growstack	src/ldo.c	/^void luaD_growstack (lua_State *L, int n) {$/;"	f
luaD_pcall	src/ldo.c	/^int luaD_pcall (lua_State *L, Pfunc func, void *u,$/;"	f
luaD_poscall	src/ldo.c	/^int luaD_poscall (lua_State *L, StkId firstResult) {$/;"	f
luaD_precall	src/ldo.c	/^int luaD_precall (lua_State *L, StkId func, int nresults) {$/;"	f
luaD_protectedparser	src/ldo.c	/^int luaD_protectedparser (lua_State *L, ZIO *z, const char *name) {$/;"	f
luaD_rawrunprotected	src/ldo.c	/^int luaD_rawrunprotected (lua_State *L, Pfunc f, void *ud) {$/;"	f
luaD_reallocCI	src/ldo.c	/^void luaD_reallocCI (lua_State *L, int newsize) {$/;"	f
luaD_reallocstack	src/ldo.c	/^void luaD_reallocstack (lua_State *L, int newsize) {$/;"	f
luaD_seterrorobj	src/ldo.c	/^void luaD_seterrorobj (lua_State *L, int errcode, StkId oldtop) {$/;"	f
luaD_throw	src/ldo.c	/^void luaD_throw (lua_State *L, int errcode) {$/;"	f
lua_longjmp	src/ldo.c	/^struct lua_longjmp {$/;"	s	file:
lua_resume	src/ldo.c	/^LUA_API int lua_resume (lua_State *L, int nargs) {$/;"	f
lua_yield	src/ldo.c	/^LUA_API int lua_yield (lua_State *L, int nresults) {$/;"	f
name	src/ldo.c	/^  const char *name;$/;"	m	struct:SParser	file:
previous	src/ldo.c	/^  struct lua_longjmp *previous;$/;"	m	struct:lua_longjmp	typeref:struct:lua_longjmp::lua_longjmp	file:
resetstack	src/ldo.c	/^static void resetstack (lua_State *L, int status) {$/;"	f	file:
restore_stack_limit	src/ldo.c	/^static void restore_stack_limit (lua_State *L) {$/;"	f	file:
resume	src/ldo.c	/^static void resume (lua_State *L, void *ud) {$/;"	f	file:
resume_error	src/ldo.c	/^static int resume_error (lua_State *L, const char *msg) {$/;"	f	file:
status	src/ldo.c	/^  volatile int status;  \/* error code *\/$/;"	m	struct:lua_longjmp	file:
tryfuncTM	src/ldo.c	/^static StkId tryfuncTM (lua_State *L, StkId func) {$/;"	f	file:
z	src/ldo.c	/^  ZIO *z;$/;"	m	struct:SParser	file:
PCRC	src/ldo.h	/^#define PCRC	/;"	d
PCRLUA	src/ldo.h	/^#define PCRLUA	/;"	d
PCRYIELD	src/ldo.h	/^#define PCRYIELD	/;"	d
Pfunc	src/ldo.h	/^typedef void (*Pfunc) (lua_State *L, void *ud);$/;"	t
incr_top	src/ldo.h	/^#define incr_top(/;"	d
ldo_h	src/ldo.h	/^#define ldo_h$/;"	d
luaD_checkstack	src/ldo.h	/^#define luaD_checkstack(/;"	d
restoreci	src/ldo.h	/^#define restoreci(/;"	d
restorestack	src/ldo.h	/^#define restorestack(/;"	d
saveci	src/ldo.h	/^#define saveci(/;"	d
savestack	src/ldo.h	/^#define savestack(/;"	d
DumpBlock	src/ldump.c	/^static void DumpBlock(const void* b, size_t size, DumpState* D)$/;"	f	file:
DumpChar	src/ldump.c	/^static void DumpChar(int y, DumpState* D)$/;"	f	file:
DumpCode	src/ldump.c	/^#define DumpCode(/;"	d	file:
DumpConstants	src/ldump.c	/^static void DumpConstants(const Proto* f, DumpState* D)$/;"	f	file:
DumpDebug	src/ldump.c	/^static void DumpDebug(const Proto* f, DumpState* D)$/;"	f	file:
DumpFunction	src/ldump.c	/^static void DumpFunction(const Proto* f, const TString* p, DumpState* D)$/;"	f	file:
DumpHeader	src/ldump.c	/^static void DumpHeader(DumpState* D)$/;"	f	file:
DumpInt	src/ldump.c	/^static void DumpInt(int x, DumpState* D)$/;"	f	file:
DumpMem	src/ldump.c	/^#define DumpMem(/;"	d	file:
DumpNumber	src/ldump.c	/^static void DumpNumber(lua_Number x, DumpState* D)$/;"	f	file:
DumpState	src/ldump.c	/^} DumpState;$/;"	t	typeref:struct:__anon1	file:
DumpString	src/ldump.c	/^static void DumpString(const TString* s, DumpState* D)$/;"	f	file:
DumpVar	src/ldump.c	/^#define DumpVar(/;"	d	file:
DumpVector	src/ldump.c	/^static void DumpVector(const void* b, int n, size_t size, DumpState* D)$/;"	f	file:
L	src/ldump.c	/^ lua_State* L;$/;"	m	struct:__anon1	file:
LUA_CORE	src/ldump.c	/^#define LUA_CORE$/;"	d	file:
data	src/ldump.c	/^ void* data;$/;"	m	struct:__anon1	file:
ldump_c	src/ldump.c	/^#define ldump_c$/;"	d	file:
luaU_dump	src/ldump.c	/^int luaU_dump (lua_State* L, const Proto* f, lua_Writer w, void* data, int strip)$/;"	f
status	src/ldump.c	/^ int status;$/;"	m	struct:__anon1	file:
strip	src/ldump.c	/^ int strip;$/;"	m	struct:__anon1	file:
writer	src/ldump.c	/^ lua_Writer writer;$/;"	m	struct:__anon1	file:
LUA_CORE	src/lfunc.c	/^#define LUA_CORE$/;"	d	file:
lfunc_c	src/lfunc.c	/^#define lfunc_c$/;"	d	file:
luaF_close	src/lfunc.c	/^void luaF_close (lua_State *L, StkId level) {$/;"	f
luaF_findupval	src/lfunc.c	/^UpVal *luaF_findupval (lua_State *L, StkId level) {$/;"	f
luaF_freeclosure	src/lfunc.c	/^void luaF_freeclosure (lua_State *L, Closure *c) {$/;"	f
luaF_freeproto	src/lfunc.c	/^void luaF_freeproto (lua_State *L, Proto *f) {$/;"	f
luaF_freeupval	src/lfunc.c	/^void luaF_freeupval (lua_State *L, UpVal *uv) {$/;"	f
luaF_getlocalname	src/lfunc.c	/^const char *luaF_getlocalname (const Proto *f, int local_number, int pc) {$/;"	f
luaF_newCclosure	src/lfunc.c	/^Closure *luaF_newCclosure (lua_State *L, int nelems, Table *e) {$/;"	f
luaF_newLclosure	src/lfunc.c	/^Closure *luaF_newLclosure (lua_State *L, int nelems, Table *e) {$/;"	f
luaF_newproto	src/lfunc.c	/^Proto *luaF_newproto (lua_State *L) {$/;"	f
luaF_newupval	src/lfunc.c	/^UpVal *luaF_newupval (lua_State *L) {$/;"	f
unlinkupval	src/lfunc.c	/^static void unlinkupval (UpVal *uv) {$/;"	f	file:
lfunc_h	src/lfunc.h	/^#define lfunc_h$/;"	d
sizeCclosure	src/lfunc.h	/^#define sizeCclosure(/;"	d
sizeLclosure	src/lfunc.h	/^#define sizeLclosure(/;"	d
GCFINALIZECOST	src/lgc.c	/^#define GCFINALIZECOST	/;"	d	file:
GCSTEPSIZE	src/lgc.c	/^#define GCSTEPSIZE	/;"	d	file:
GCSWEEPCOST	src/lgc.c	/^#define GCSWEEPCOST	/;"	d	file:
GCSWEEPMAX	src/lgc.c	/^#define GCSWEEPMAX	/;"	d	file:
GCTM	src/lgc.c	/^static void GCTM (lua_State *L) {$/;"	f	file:
KEYWEAK	src/lgc.c	/^#define KEYWEAK /;"	d	file:
LUA_CORE	src/lgc.c	/^#define LUA_CORE$/;"	d	file:
VALUEWEAK	src/lgc.c	/^#define VALUEWEAK /;"	d	file:
atomic	src/lgc.c	/^static void atomic (lua_State *L) {$/;"	f	file:
black2gray	src/lgc.c	/^#define black2gray(/;"	d	file:
checkSizes	src/lgc.c	/^static void checkSizes (lua_State *L) {$/;"	f	file:
checkstacksizes	src/lgc.c	/^static void checkstacksizes (lua_State *L, StkId max) {$/;"	f	file:
cleartable	src/lgc.c	/^static void cleartable (GCObject *l) {$/;"	f	file:
freeobj	src/lgc.c	/^static void freeobj (lua_State *L, GCObject *o) {$/;"	f	file:
iscleared	src/lgc.c	/^static int iscleared (const TValue *o, int iskey) {$/;"	f	file:
isfinalized	src/lgc.c	/^#define isfinalized(/;"	d	file:
lgc_c	src/lgc.c	/^#define lgc_c$/;"	d	file:
luaC_barrierback	src/lgc.c	/^void luaC_barrierback (lua_State *L, Table *t) {$/;"	f
luaC_barrierf	src/lgc.c	/^void luaC_barrierf (lua_State *L, GCObject *o, GCObject *v) {$/;"	f
luaC_callGCTM	src/lgc.c	/^void luaC_callGCTM (lua_State *L) {$/;"	f
luaC_freeall	src/lgc.c	/^void luaC_freeall (lua_State *L) {$/;"	f
luaC_fullgc	src/lgc.c	/^void luaC_fullgc (lua_State *L) {$/;"	f
luaC_link	src/lgc.c	/^void luaC_link (lua_State *L, GCObject *o, lu_byte tt) {$/;"	f
luaC_linkupval	src/lgc.c	/^void luaC_linkupval (lua_State *L, UpVal *uv) {$/;"	f
luaC_separateudata	src/lgc.c	/^size_t luaC_separateudata (lua_State *L, int all) {$/;"	f
luaC_step	src/lgc.c	/^void luaC_step (lua_State *L) {$/;"	f
makewhite	src/lgc.c	/^#define makewhite(/;"	d	file:
markfinalized	src/lgc.c	/^#define markfinalized(/;"	d	file:
markmt	src/lgc.c	/^static void markmt (global_State *g) {$/;"	f	file:
markobject	src/lgc.c	/^#define markobject(/;"	d	file:
markroot	src/lgc.c	/^static void markroot (lua_State *L) {$/;"	f	file:
marktmu	src/lgc.c	/^static void marktmu (global_State *g) {$/;"	f	file:
markvalue	src/lgc.c	/^#define markvalue(/;"	d	file:
maskmarks	src/lgc.c	/^#define maskmarks	/;"	d	file:
propagateall	src/lgc.c	/^static size_t propagateall (global_State *g) {$/;"	f	file:
propagatemark	src/lgc.c	/^static l_mem propagatemark (global_State *g) {$/;"	f	file:
reallymarkobject	src/lgc.c	/^static void reallymarkobject (global_State *g, GCObject *o) {$/;"	f	file:
remarkupvals	src/lgc.c	/^static void remarkupvals (global_State *g) {$/;"	f	file:
removeentry	src/lgc.c	/^static void removeentry (Node *n) {$/;"	f	file:
setthreshold	src/lgc.c	/^#define setthreshold(/;"	d	file:
singlestep	src/lgc.c	/^static l_mem singlestep (lua_State *L) {$/;"	f	file:
stringmark	src/lgc.c	/^#define stringmark(/;"	d	file:
sweeplist	src/lgc.c	/^static GCObject **sweeplist (lua_State *L, GCObject **p, lu_mem count) {$/;"	f	file:
sweepwholelist	src/lgc.c	/^#define sweepwholelist(/;"	d	file:
traverseclosure	src/lgc.c	/^static void traverseclosure (global_State *g, Closure *cl) {$/;"	f	file:
traverseproto	src/lgc.c	/^static void traverseproto (global_State *g, Proto *f) {$/;"	f	file:
traversestack	src/lgc.c	/^static void traversestack (global_State *g, lua_State *l) {$/;"	f	file:
traversetable	src/lgc.c	/^static int traversetable (global_State *g, Table *h) {$/;"	f	file:
white2gray	src/lgc.c	/^#define white2gray(/;"	d	file:
BLACKBIT	src/lgc.h	/^#define BLACKBIT	/;"	d
FINALIZEDBIT	src/lgc.h	/^#define FINALIZEDBIT	/;"	d
FIXEDBIT	src/lgc.h	/^#define FIXEDBIT	/;"	d
GCSfinalize	src/lgc.h	/^#define GCSfinalize	/;"	d
GCSpause	src/lgc.h	/^#define GCSpause	/;"	d
GCSpropagate	src/lgc.h	/^#define GCSpropagate	/;"	d
GCSsweep	src/lgc.h	/^#define GCSsweep	/;"	d
GCSsweepstring	src/lgc.h	/^#define GCSsweepstring	/;"	d
KEYWEAKBIT	src/lgc.h	/^#define KEYWEAKBIT	/;"	d
SFIXEDBIT	src/lgc.h	/^#define SFIXEDBIT	/;"	d
VALUEWEAKBIT	src/lgc.h	/^#define VALUEWEAKBIT	/;"	d
WHITE0BIT	src/lgc.h	/^#define WHITE0BIT	/;"	d
WHITE1BIT	src/lgc.h	/^#define WHITE1BIT	/;"	d
WHITEBITS	src/lgc.h	/^#define WHITEBITS	/;"	d
bit2mask	src/lgc.h	/^#define bit2mask(/;"	d
bitmask	src/lgc.h	/^#define bitmask(/;"	d
changewhite	src/lgc.h	/^#define changewhite(/;"	d
gray2black	src/lgc.h	/^#define gray2black(/;"	d
isblack	src/lgc.h	/^#define isblack(/;"	d
isdead	src/lgc.h	/^#define isdead(/;"	d
isgray	src/lgc.h	/^#define isgray(/;"	d
iswhite	src/lgc.h	/^#define iswhite(/;"	d
l_setbit	src/lgc.h	/^#define l_setbit(/;"	d
lgc_h	src/lgc.h	/^#define lgc_h$/;"	d
luaC_barrier	src/lgc.h	/^#define luaC_barrier(/;"	d
luaC_barriert	src/lgc.h	/^#define luaC_barriert(/;"	d
luaC_checkGC	src/lgc.h	/^#define luaC_checkGC(/;"	d
luaC_objbarrier	src/lgc.h	/^#define luaC_objbarrier(/;"	d
luaC_objbarriert	src/lgc.h	/^#define luaC_objbarriert(/;"	d
luaC_white	src/lgc.h	/^#define luaC_white(/;"	d
otherwhite	src/lgc.h	/^#define otherwhite(/;"	d
reset2bits	src/lgc.h	/^#define reset2bits(/;"	d
resetbit	src/lgc.h	/^#define resetbit(/;"	d
resetbits	src/lgc.h	/^#define resetbits(/;"	d
set2bits	src/lgc.h	/^#define set2bits(/;"	d
setbits	src/lgc.h	/^#define setbits(/;"	d
test2bits	src/lgc.h	/^#define test2bits(/;"	d
testbit	src/lgc.h	/^#define testbit(/;"	d
testbits	src/lgc.h	/^#define testbits(/;"	d
valiswhite	src/lgc.h	/^#define valiswhite(/;"	d
LUA_LIB	src/linit.c	/^#define LUA_LIB$/;"	d	file:
linit_c	src/linit.c	/^#define linit_c$/;"	d	file:
luaL_openlibs	src/linit.c	/^LUALIB_API void luaL_openlibs (lua_State *L) {$/;"	f
lualibs	src/linit.c	/^static const luaL_Reg lualibs[] = {$/;"	v	file:
IO_INPUT	src/liolib.c	/^#define IO_INPUT	/;"	d	file:
IO_OUTPUT	src/liolib.c	/^#define IO_OUTPUT	/;"	d	file:
LUA_LIB	src/liolib.c	/^#define LUA_LIB$/;"	d	file:
aux_close	src/liolib.c	/^static int aux_close (lua_State *L) {$/;"	f	file:
aux_lines	src/liolib.c	/^static void aux_lines (lua_State *L, int idx, int toclose) {$/;"	f	file:
createmeta	src/liolib.c	/^static void createmeta (lua_State *L) {$/;"	f	file:
createstdfile	src/liolib.c	/^static void createstdfile (lua_State *L, FILE *f, int k, const char *fname) {$/;"	f	file:
f_flush	src/liolib.c	/^static int f_flush (lua_State *L) {$/;"	f	file:
f_lines	src/liolib.c	/^static int f_lines (lua_State *L) {$/;"	f	file:
f_read	src/liolib.c	/^static int f_read (lua_State *L) {$/;"	f	file:
f_seek	src/liolib.c	/^static int f_seek (lua_State *L) {$/;"	f	file:
f_setvbuf	src/liolib.c	/^static int f_setvbuf (lua_State *L) {$/;"	f	file:
f_write	src/liolib.c	/^static int f_write (lua_State *L) {$/;"	f	file:
fileerror	src/liolib.c	/^static void fileerror (lua_State *L, int arg, const char *filename) {$/;"	f	file:
flib	src/liolib.c	/^static const luaL_Reg flib[] = {$/;"	v	file:
fnames	src/liolib.c	/^static const char *const fnames[] = {"input", "output"};$/;"	v	file:
g_iofile	src/liolib.c	/^static int g_iofile (lua_State *L, int f, const char *mode) {$/;"	f	file:
g_read	src/liolib.c	/^static int g_read (lua_State *L, FILE *f, int first) {$/;"	f	file:
g_write	src/liolib.c	/^static int g_write (lua_State *L, FILE *f, int arg) {$/;"	f	file:
getiofile	src/liolib.c	/^static FILE *getiofile (lua_State *L, int findex) {$/;"	f	file:
io_close	src/liolib.c	/^static int io_close (lua_State *L) {$/;"	f	file:
io_fclose	src/liolib.c	/^static int io_fclose (lua_State *L) {$/;"	f	file:
io_flush	src/liolib.c	/^static int io_flush (lua_State *L) {$/;"	f	file:
io_gc	src/liolib.c	/^static int io_gc (lua_State *L) {$/;"	f	file:
io_input	src/liolib.c	/^static int io_input (lua_State *L) {$/;"	f	file:
io_lines	src/liolib.c	/^static int io_lines (lua_State *L) {$/;"	f	file:
io_noclose	src/liolib.c	/^static int io_noclose (lua_State *L) {$/;"	f	file:
io_open	src/liolib.c	/^static int io_open (lua_State *L) {$/;"	f	file:
io_output	src/liolib.c	/^static int io_output (lua_State *L) {$/;"	f	file:
io_pclose	src/liolib.c	/^static int io_pclose (lua_State *L) {$/;"	f	file:
io_popen	src/liolib.c	/^static int io_popen (lua_State *L) {$/;"	f	file:
io_read	src/liolib.c	/^static int io_read (lua_State *L) {$/;"	f	file:
io_readline	src/liolib.c	/^static int io_readline (lua_State *L) {$/;"	f	file:
io_tmpfile	src/liolib.c	/^static int io_tmpfile (lua_State *L) {$/;"	f	file:
io_tostring	src/liolib.c	/^static int io_tostring (lua_State *L) {$/;"	f	file:
io_type	src/liolib.c	/^static int io_type (lua_State *L) {$/;"	f	file:
io_write	src/liolib.c	/^static int io_write (lua_State *L) {$/;"	f	file:
iolib	src/liolib.c	/^static const luaL_Reg iolib[] = {$/;"	v	file:
liolib_c	src/liolib.c	/^#define liolib_c$/;"	d	file:
luaopen_io	src/liolib.c	/^LUALIB_API int luaopen_io (lua_State *L) {$/;"	f
newfenv	src/liolib.c	/^static void newfenv (lua_State *L, lua_CFunction cls) {$/;"	f	file:
newfile	src/liolib.c	/^static FILE **newfile (lua_State *L) {$/;"	f	file:
pushresult	src/liolib.c	/^static int pushresult (lua_State *L, int i, const char *filename) {$/;"	f	file:
read_chars	src/liolib.c	/^static int read_chars (lua_State *L, FILE *f, size_t n) {$/;"	f	file:
read_line	src/liolib.c	/^static int read_line (lua_State *L, FILE *f) {$/;"	f	file:
read_number	src/liolib.c	/^static int read_number (lua_State *L, FILE *f) {$/;"	f	file:
test_eof	src/liolib.c	/^static int test_eof (lua_State *L, FILE *f) {$/;"	f	file:
tofile	src/liolib.c	/^static FILE *tofile (lua_State *L) {$/;"	f	file:
tofilep	src/liolib.c	/^#define tofilep(/;"	d	file:
LUA_CORE	src/llex.c	/^#define LUA_CORE$/;"	d	file:
MAXSRC	src/llex.c	/^#define MAXSRC /;"	d	file:
buffreplace	src/llex.c	/^static void buffreplace (LexState *ls, char from, char to) {$/;"	f	file:
check_next	src/llex.c	/^static int check_next (LexState *ls, const char *set) {$/;"	f	file:
currIsNewline	src/llex.c	/^#define currIsNewline(/;"	d	file:
inclinenumber	src/llex.c	/^static void inclinenumber (LexState *ls) {$/;"	f	file:
llex	src/llex.c	/^static int llex (LexState *ls, SemInfo *seminfo) {$/;"	f	file:
llex_c	src/llex.c	/^#define llex_c$/;"	d	file:
luaX_init	src/llex.c	/^void luaX_init (lua_State *L) {$/;"	f
luaX_lexerror	src/llex.c	/^void luaX_lexerror (LexState *ls, const char *msg, int token) {$/;"	f
luaX_lookahead	src/llex.c	/^void luaX_lookahead (LexState *ls) {$/;"	f
luaX_newstring	src/llex.c	/^TString *luaX_newstring (LexState *ls, const char *str, size_t l) {$/;"	f
luaX_next	src/llex.c	/^void luaX_next (LexState *ls) {$/;"	f
luaX_setinput	src/llex.c	/^void luaX_setinput (lua_State *L, LexState *ls, ZIO *z, TString *source) {$/;"	f
luaX_syntaxerror	src/llex.c	/^void luaX_syntaxerror (LexState *ls, const char *msg) {$/;"	f
luaX_token2str	src/llex.c	/^const char *luaX_token2str (LexState *ls, int token) {$/;"	f
luaX_tokens	src/llex.c	/^const char *const luaX_tokens [] = {$/;"	v
next	src/llex.c	/^#define next(/;"	d	file:
read_long_string	src/llex.c	/^static void read_long_string (LexState *ls, SemInfo *seminfo, int sep) {$/;"	f	file:
read_numeral	src/llex.c	/^static void read_numeral (LexState *ls, SemInfo *seminfo) {$/;"	f	file:
read_string	src/llex.c	/^static void read_string (LexState *ls, int del, SemInfo *seminfo) {$/;"	f	file:
save	src/llex.c	/^static void save (LexState *ls, int c) {$/;"	f	file:
save_and_next	src/llex.c	/^#define save_and_next(/;"	d	file:
skip_sep	src/llex.c	/^static int skip_sep (LexState *ls) {$/;"	f	file:
trydecpoint	src/llex.c	/^static void trydecpoint (LexState *ls, SemInfo *seminfo) {$/;"	f	file:
txtToken	src/llex.c	/^static const char *txtToken (LexState *ls, int token) {$/;"	f	file:
FIRST_RESERVED	src/llex.h	/^#define FIRST_RESERVED	/;"	d
L	src/llex.h	/^  struct lua_State *L;$/;"	m	struct:LexState	typeref:struct:LexState::lua_State
LexState	src/llex.h	/^typedef struct LexState {$/;"	s
LexState	src/llex.h	/^} LexState;$/;"	t	typeref:struct:LexState
NUM_RESERVED	src/llex.h	/^#define NUM_RESERVED	/;"	d
RESERVED	src/llex.h	/^enum RESERVED {$/;"	g
SemInfo	src/llex.h	/^} SemInfo;  \/* semantics information *\/$/;"	t	typeref:union:__anon2
TK_AND	src/llex.h	/^  TK_AND = FIRST_RESERVED, TK_BREAK,$/;"	e	enum:RESERVED
TK_BREAK	src/llex.h	/^  TK_AND = FIRST_RESERVED, TK_BREAK,$/;"	e	enum:RESERVED
TK_CONCAT	src/llex.h	/^  TK_CONCAT, TK_DOTS, TK_EQ, TK_GE, TK_LE, TK_NE, TK_NUMBER,$/;"	e	enum:RESERVED
TK_DO	src/llex.h	/^  TK_DO, TK_ELSE, TK_ELSEIF, TK_END, TK_FALSE, TK_FOR, TK_FUNCTION,$/;"	e	enum:RESERVED
TK_DOTS	src/llex.h	/^  TK_CONCAT, TK_DOTS, TK_EQ, TK_GE, TK_LE, TK_NE, TK_NUMBER,$/;"	e	enum:RESERVED
TK_ELSE	src/llex.h	/^  TK_DO, TK_ELSE, TK_ELSEIF, TK_END, TK_FALSE, TK_FOR, TK_FUNCTION,$/;"	e	enum:RESERVED
TK_ELSEIF	src/llex.h	/^  TK_DO, TK_ELSE, TK_ELSEIF, TK_END, TK_FALSE, TK_FOR, TK_FUNCTION,$/;"	e	enum:RESERVED
TK_END	src/llex.h	/^  TK_DO, TK_ELSE, TK_ELSEIF, TK_END, TK_FALSE, TK_FOR, TK_FUNCTION,$/;"	e	enum:RESERVED
TK_EOS	src/llex.h	/^  TK_NAME, TK_STRING, TK_EOS$/;"	e	enum:RESERVED
TK_EQ	src/llex.h	/^  TK_CONCAT, TK_DOTS, TK_EQ, TK_GE, TK_LE, TK_NE, TK_NUMBER,$/;"	e	enum:RESERVED
TK_FALSE	src/llex.h	/^  TK_DO, TK_ELSE, TK_ELSEIF, TK_END, TK_FALSE, TK_FOR, TK_FUNCTION,$/;"	e	enum:RESERVED
TK_FOR	src/llex.h	/^  TK_DO, TK_ELSE, TK_ELSEIF, TK_END, TK_FALSE, TK_FOR, TK_FUNCTION,$/;"	e	enum:RESERVED
TK_FUNCTION	src/llex.h	/^  TK_DO, TK_ELSE, TK_ELSEIF, TK_END, TK_FALSE, TK_FOR, TK_FUNCTION,$/;"	e	enum:RESERVED
TK_GE	src/llex.h	/^  TK_CONCAT, TK_DOTS, TK_EQ, TK_GE, TK_LE, TK_NE, TK_NUMBER,$/;"	e	enum:RESERVED
TK_IF	src/llex.h	/^  TK_IF, TK_IN, TK_LOCAL, TK_NIL, TK_NOT, TK_OR, TK_REPEAT,$/;"	e	enum:RESERVED
TK_IN	src/llex.h	/^  TK_IF, TK_IN, TK_LOCAL, TK_NIL, TK_NOT, TK_OR, TK_REPEAT,$/;"	e	enum:RESERVED
TK_LE	src/llex.h	/^  TK_CONCAT, TK_DOTS, TK_EQ, TK_GE, TK_LE, TK_NE, TK_NUMBER,$/;"	e	enum:RESERVED
TK_LOCAL	src/llex.h	/^  TK_IF, TK_IN, TK_LOCAL, TK_NIL, TK_NOT, TK_OR, TK_REPEAT,$/;"	e	enum:RESERVED
TK_NAME	src/llex.h	/^  TK_NAME, TK_STRING, TK_EOS$/;"	e	enum:RESERVED
TK_NE	src/llex.h	/^  TK_CONCAT, TK_DOTS, TK_EQ, TK_GE, TK_LE, TK_NE, TK_NUMBER,$/;"	e	enum:RESERVED
TK_NIL	src/llex.h	/^  TK_IF, TK_IN, TK_LOCAL, TK_NIL, TK_NOT, TK_OR, TK_REPEAT,$/;"	e	enum:RESERVED
TK_NOT	src/llex.h	/^  TK_IF, TK_IN, TK_LOCAL, TK_NIL, TK_NOT, TK_OR, TK_REPEAT,$/;"	e	enum:RESERVED
TK_NUMBER	src/llex.h	/^  TK_CONCAT, TK_DOTS, TK_EQ, TK_GE, TK_LE, TK_NE, TK_NUMBER,$/;"	e	enum:RESERVED
TK_OR	src/llex.h	/^  TK_IF, TK_IN, TK_LOCAL, TK_NIL, TK_NOT, TK_OR, TK_REPEAT,$/;"	e	enum:RESERVED
TK_REPEAT	src/llex.h	/^  TK_IF, TK_IN, TK_LOCAL, TK_NIL, TK_NOT, TK_OR, TK_REPEAT,$/;"	e	enum:RESERVED
TK_RETURN	src/llex.h	/^  TK_RETURN, TK_THEN, TK_TRUE, TK_UNTIL, TK_WHILE,$/;"	e	enum:RESERVED
TK_STRING	src/llex.h	/^  TK_NAME, TK_STRING, TK_EOS$/;"	e	enum:RESERVED
TK_THEN	src/llex.h	/^  TK_RETURN, TK_THEN, TK_TRUE, TK_UNTIL, TK_WHILE,$/;"	e	enum:RESERVED
TK_TRUE	src/llex.h	/^  TK_RETURN, TK_THEN, TK_TRUE, TK_UNTIL, TK_WHILE,$/;"	e	enum:RESERVED
TK_UNTIL	src/llex.h	/^  TK_RETURN, TK_THEN, TK_TRUE, TK_UNTIL, TK_WHILE,$/;"	e	enum:RESERVED
TK_WHILE	src/llex.h	/^  TK_RETURN, TK_THEN, TK_TRUE, TK_UNTIL, TK_WHILE,$/;"	e	enum:RESERVED
TOKEN_LEN	src/llex.h	/^#define TOKEN_LEN	/;"	d
Token	src/llex.h	/^typedef struct Token {$/;"	s
Token	src/llex.h	/^} Token;$/;"	t	typeref:struct:Token
buff	src/llex.h	/^  Mbuffer *buff;  \/* buffer for tokens *\/$/;"	m	struct:LexState
current	src/llex.h	/^  int current;  \/* current character (charint) *\/$/;"	m	struct:LexState
decpoint	src/llex.h	/^  char decpoint;  \/* locale decimal point *\/$/;"	m	struct:LexState
fs	src/llex.h	/^  struct FuncState *fs;  \/* `FuncState' is private to the parser *\/$/;"	m	struct:LexState	typeref:struct:LexState::FuncState
lastline	src/llex.h	/^  int lastline;  \/* line of last token `consumed' *\/$/;"	m	struct:LexState
linenumber	src/llex.h	/^  int linenumber;  \/* input line counter *\/$/;"	m	struct:LexState
llex_h	src/llex.h	/^#define llex_h$/;"	d
lookahead	src/llex.h	/^  Token lookahead;  \/* look ahead token *\/$/;"	m	struct:LexState
luaX_tokens	src/llex.h	/^LUAI_DATA const char *const luaX_tokens [];$/;"	v
r	src/llex.h	/^  lua_Number r;$/;"	m	union:__anon2
seminfo	src/llex.h	/^  SemInfo seminfo;$/;"	m	struct:Token
source	src/llex.h	/^  TString *source;  \/* current source name *\/$/;"	m	struct:LexState
t	src/llex.h	/^  Token t;  \/* current token *\/$/;"	m	struct:LexState
token	src/llex.h	/^  int token;$/;"	m	struct:Token
ts	src/llex.h	/^  TString *ts;$/;"	m	union:__anon2
z	src/llex.h	/^  ZIO *z;  \/* input stream *\/$/;"	m	struct:LexState
Instruction	src/llimits.h	/^typedef lu_int32 Instruction;$/;"	t
IntPoint	src/llimits.h	/^#define IntPoint(/;"	d
LUA_MINBUFFER	src/llimits.h	/^#define LUA_MINBUFFER	/;"	d
L_Umaxalign	src/llimits.h	/^typedef LUAI_USER_ALIGNMENT_T L_Umaxalign;$/;"	t
MAXSTACK	src/llimits.h	/^#define MAXSTACK	/;"	d
MAX_INT	src/llimits.h	/^#define MAX_INT /;"	d
MAX_LUMEM	src/llimits.h	/^#define MAX_LUMEM	/;"	d
MAX_SIZET	src/llimits.h	/^#define MAX_SIZET	/;"	d
MINSTRTABSIZE	src/llimits.h	/^#define MINSTRTABSIZE	/;"	d
UNUSED	src/llimits.h	/^#define UNUSED(/;"	d
api_check	src/llimits.h	/^#define api_check	/;"	d
api_check	src/llimits.h	/^#define api_check(/;"	d
cast	src/llimits.h	/^#define cast(/;"	d
cast_byte	src/llimits.h	/^#define cast_byte(/;"	d
cast_int	src/llimits.h	/^#define cast_int(/;"	d
cast_num	src/llimits.h	/^#define cast_num(/;"	d
check_exp	src/llimits.h	/^#define check_exp(/;"	d
condhardstacktests	src/llimits.h	/^#define condhardstacktests(/;"	d
l_mem	src/llimits.h	/^typedef LUAI_MEM l_mem;$/;"	t
l_uacNumber	src/llimits.h	/^typedef LUAI_UACNUMBER l_uacNumber;$/;"	t
llimits_h	src/llimits.h	/^#define llimits_h$/;"	d
lu_byte	src/llimits.h	/^typedef unsigned char lu_byte;$/;"	t
lu_int32	src/llimits.h	/^typedef LUAI_UINT32 lu_int32;$/;"	t
lu_mem	src/llimits.h	/^typedef LUAI_UMEM lu_mem;$/;"	t
lua_assert	src/llimits.h	/^#define lua_assert(/;"	d
lua_lock	src/llimits.h	/^#define lua_lock(/;"	d
lua_unlock	src/llimits.h	/^#define lua_unlock(/;"	d
luai_threadyield	src/llimits.h	/^#define luai_threadyield(/;"	d
LUA_LIB	src/lmathlib.c	/^#define LUA_LIB$/;"	d	file:
PI	src/lmathlib.c	/^#define PI /;"	d	file:
PI	src/lmathlib.c	/^#undef PI$/;"	d	file:
RADIANS_PER_DEGREE	src/lmathlib.c	/^#define RADIANS_PER_DEGREE /;"	d	file:
lmathlib_c	src/lmathlib.c	/^#define lmathlib_c$/;"	d	file:
luaopen_math	src/lmathlib.c	/^LUALIB_API int luaopen_math (lua_State *L) {$/;"	f
math_abs	src/lmathlib.c	/^static int math_abs (lua_State *L) {$/;"	f	file:
math_acos	src/lmathlib.c	/^static int math_acos (lua_State *L) {$/;"	f	file:
math_asin	src/lmathlib.c	/^static int math_asin (lua_State *L) {$/;"	f	file:
math_atan	src/lmathlib.c	/^static int math_atan (lua_State *L) {$/;"	f	file:
math_atan2	src/lmathlib.c	/^static int math_atan2 (lua_State *L) {$/;"	f	file:
math_ceil	src/lmathlib.c	/^static int math_ceil (lua_State *L) {$/;"	f	file:
math_cos	src/lmathlib.c	/^static int math_cos (lua_State *L) {$/;"	f	file:
math_cosh	src/lmathlib.c	/^static int math_cosh (lua_State *L) {$/;"	f	file:
math_deg	src/lmathlib.c	/^static int math_deg (lua_State *L) {$/;"	f	file:
math_exp	src/lmathlib.c	/^static int math_exp (lua_State *L) {$/;"	f	file:
math_floor	src/lmathlib.c	/^static int math_floor (lua_State *L) {$/;"	f	file:
math_fmod	src/lmathlib.c	/^static int math_fmod (lua_State *L) {$/;"	f	file:
math_frexp	src/lmathlib.c	/^static int math_frexp (lua_State *L) {$/;"	f	file:
math_ldexp	src/lmathlib.c	/^static int math_ldexp (lua_State *L) {$/;"	f	file:
math_log	src/lmathlib.c	/^static int math_log (lua_State *L) {$/;"	f	file:
math_log10	src/lmathlib.c	/^static int math_log10 (lua_State *L) {$/;"	f	file:
math_max	src/lmathlib.c	/^static int math_max (lua_State *L) {$/;"	f	file:
math_min	src/lmathlib.c	/^static int math_min (lua_State *L) {$/;"	f	file:
math_modf	src/lmathlib.c	/^static int math_modf (lua_State *L) {$/;"	f	file:
math_pow	src/lmathlib.c	/^static int math_pow (lua_State *L) {$/;"	f	file:
math_rad	src/lmathlib.c	/^static int math_rad (lua_State *L) {$/;"	f	file:
math_random	src/lmathlib.c	/^static int math_random (lua_State *L) {$/;"	f	file:
math_randomseed	src/lmathlib.c	/^static int math_randomseed (lua_State *L) {$/;"	f	file:
math_sin	src/lmathlib.c	/^static int math_sin (lua_State *L) {$/;"	f	file:
math_sinh	src/lmathlib.c	/^static int math_sinh (lua_State *L) {$/;"	f	file:
math_sqrt	src/lmathlib.c	/^static int math_sqrt (lua_State *L) {$/;"	f	file:
math_tan	src/lmathlib.c	/^static int math_tan (lua_State *L) {$/;"	f	file:
math_tanh	src/lmathlib.c	/^static int math_tanh (lua_State *L) {$/;"	f	file:
mathlib	src/lmathlib.c	/^static const luaL_Reg mathlib[] = {$/;"	v	file:
LUA_CORE	src/lmem.c	/^#define LUA_CORE$/;"	d	file:
MINSIZEARRAY	src/lmem.c	/^#define MINSIZEARRAY	/;"	d	file:
lmem_c	src/lmem.c	/^#define lmem_c$/;"	d	file:
luaM_growaux_	src/lmem.c	/^void *luaM_growaux_ (lua_State *L, void *block, int *size, size_t size_elems,$/;"	f
luaM_realloc_	src/lmem.c	/^void *luaM_realloc_ (lua_State *L, void *block, size_t osize, size_t nsize) {$/;"	f
luaM_toobig	src/lmem.c	/^void *luaM_toobig (lua_State *L) {$/;"	f
MEMERRMSG	src/lmem.h	/^#define MEMERRMSG	/;"	d
lmem_h	src/lmem.h	/^#define lmem_h$/;"	d
luaM_free	src/lmem.h	/^#define luaM_free(/;"	d
luaM_freearray	src/lmem.h	/^#define luaM_freearray(/;"	d
luaM_freemem	src/lmem.h	/^#define luaM_freemem(/;"	d
luaM_growvector	src/lmem.h	/^#define luaM_growvector(/;"	d
luaM_malloc	src/lmem.h	/^#define luaM_malloc(/;"	d
luaM_new	src/lmem.h	/^#define luaM_new(/;"	d
luaM_newvector	src/lmem.h	/^#define luaM_newvector(/;"	d
luaM_reallocv	src/lmem.h	/^#define luaM_reallocv(/;"	d
luaM_reallocvector	src/lmem.h	/^#define luaM_reallocvector(/;"	d
AUXMARK	src/loadlib.c	/^#define AUXMARK	/;"	d	file:
DLMSG	src/loadlib.c	/^#define DLMSG	/;"	d	file:
ERRFUNC	src/loadlib.c	/^#define ERRFUNC	/;"	d	file:
ERRLIB	src/loadlib.c	/^#define ERRLIB	/;"	d	file:
LIBPREFIX	src/loadlib.c	/^#define LIBPREFIX	/;"	d	file:
LIB_FAIL	src/loadlib.c	/^#define LIB_FAIL	/;"	d	file:
LIB_FAIL	src/loadlib.c	/^#undef LIB_FAIL$/;"	d	file:
LUA_LIB	src/loadlib.c	/^#define LUA_LIB$/;"	d	file:
LUA_OFSEP	src/loadlib.c	/^#define LUA_OFSEP	/;"	d	file:
LUA_POF	src/loadlib.c	/^#define LUA_POF	/;"	d	file:
POF	src/loadlib.c	/^#define POF	/;"	d	file:
POF	src/loadlib.c	/^#undef POF$/;"	d	file:
dooptions	src/loadlib.c	/^static void dooptions (lua_State *L, int n) {$/;"	f	file:
errorfromcode	src/loadlib.c	/^static const char *errorfromcode (NSObjectFileImageReturnCode ret) {$/;"	f	file:
findfile	src/loadlib.c	/^static const char *findfile (lua_State *L, const char *name,$/;"	f	file:
gctm	src/loadlib.c	/^static int gctm (lua_State *L) {$/;"	f	file:
ll_funcs	src/loadlib.c	/^static const luaL_Reg ll_funcs[] = {$/;"	v	file:
ll_load	src/loadlib.c	/^static void *ll_load (lua_State *L, const char *path) {$/;"	f	file:
ll_loadfunc	src/loadlib.c	/^static int ll_loadfunc (lua_State *L, const char *path, const char *sym) {$/;"	f	file:
ll_loadlib	src/loadlib.c	/^static int ll_loadlib (lua_State *L) {$/;"	f	file:
ll_module	src/loadlib.c	/^static int ll_module (lua_State *L) {$/;"	f	file:
ll_register	src/loadlib.c	/^static void **ll_register (lua_State *L, const char *path) {$/;"	f	file:
ll_require	src/loadlib.c	/^static int ll_require (lua_State *L) {$/;"	f	file:
ll_seeall	src/loadlib.c	/^static int ll_seeall (lua_State *L) {$/;"	f	file:
ll_sym	src/loadlib.c	/^static lua_CFunction ll_sym (lua_State *L, void *lib, const char *sym) {$/;"	f	file:
ll_unloadlib	src/loadlib.c	/^static void ll_unloadlib (void *lib) {$/;"	f	file:
loader_C	src/loadlib.c	/^static int loader_C (lua_State *L) {$/;"	f	file:
loader_Croot	src/loadlib.c	/^static int loader_Croot (lua_State *L) {$/;"	f	file:
loader_Lua	src/loadlib.c	/^static int loader_Lua (lua_State *L) {$/;"	f	file:
loader_preload	src/loadlib.c	/^static int loader_preload (lua_State *L) {$/;"	f	file:
loaderror	src/loadlib.c	/^static void loaderror (lua_State *L, const char *filename) {$/;"	f	file:
loaders	src/loadlib.c	/^static const lua_CFunction loaders[] =$/;"	v	file:
loadlib_c	src/loadlib.c	/^#define loadlib_c$/;"	d	file:
luaopen_package	src/loadlib.c	/^LUALIB_API int luaopen_package (lua_State *L) {$/;"	f
mkfuncname	src/loadlib.c	/^static const char *mkfuncname (lua_State *L, const char *modname) {$/;"	f	file:
modinit	src/loadlib.c	/^static void modinit (lua_State *L, const char *modname) {$/;"	f	file:
pk_funcs	src/loadlib.c	/^static const luaL_Reg pk_funcs[] = {$/;"	v	file:
pusherror	src/loadlib.c	/^static void pusherror (lua_State *L) {$/;"	f	file:
pushnexttemplate	src/loadlib.c	/^static const char *pushnexttemplate (lua_State *L, const char *path) {$/;"	f	file:
readable	src/loadlib.c	/^static int readable (const char *filename) {$/;"	f	file:
sentinel	src/loadlib.c	/^#define sentinel	/;"	d	file:
sentinel_	src/loadlib.c	/^static const int sentinel_ = 0;$/;"	v	file:
setfenv	src/loadlib.c	/^static void setfenv (lua_State *L) {$/;"	f	file:
setpath	src/loadlib.c	/^static void setpath (lua_State *L, const char *fieldname, const char *envname,$/;"	f	file:
setprogdir	src/loadlib.c	/^#define setprogdir(/;"	d	file:
setprogdir	src/loadlib.c	/^#undef setprogdir$/;"	d	file:
setprogdir	src/loadlib.c	/^static void setprogdir (lua_State *L) {$/;"	f	file:
LUA_CORE	src/lobject.c	/^#define LUA_CORE$/;"	d	file:
lobject_c	src/lobject.c	/^#define lobject_c$/;"	d	file:
luaO_chunkid	src/lobject.c	/^void luaO_chunkid (char *out, const char *source, size_t bufflen) {$/;"	f
luaO_fb2int	src/lobject.c	/^int luaO_fb2int (int x) {$/;"	f
luaO_int2fb	src/lobject.c	/^int luaO_int2fb (unsigned int x) {$/;"	f
luaO_log2	src/lobject.c	/^int luaO_log2 (unsigned int x) {$/;"	f
luaO_nilobject_	src/lobject.c	/^const TValue luaO_nilobject_ = {{NULL}, LUA_TNIL};$/;"	v
luaO_pushfstring	src/lobject.c	/^const char *luaO_pushfstring (lua_State *L, const char *fmt, ...) {$/;"	f
luaO_pushvfstring	src/lobject.c	/^const char *luaO_pushvfstring (lua_State *L, const char *fmt, va_list argp) {$/;"	f
luaO_rawequalObj	src/lobject.c	/^int luaO_rawequalObj (const TValue *t1, const TValue *t2) {$/;"	f
luaO_str2d	src/lobject.c	/^int luaO_str2d (const char *s, lua_Number *result) {$/;"	f
pushstr	src/lobject.c	/^static void pushstr (lua_State *L, const char *str) {$/;"	f	file:
CClosure	src/lobject.h	/^typedef struct CClosure {$/;"	s
CClosure	src/lobject.h	/^} CClosure;$/;"	t	typeref:struct:CClosure
Closure	src/lobject.h	/^typedef union Closure {$/;"	u
Closure	src/lobject.h	/^} Closure;$/;"	t	typeref:union:Closure
ClosureHeader	src/lobject.h	/^  ClosureHeader;$/;"	m	struct:CClosure
ClosureHeader	src/lobject.h	/^  ClosureHeader;$/;"	m	struct:LClosure
ClosureHeader	src/lobject.h	/^#define ClosureHeader /;"	d
CommonHeader	src/lobject.h	/^    CommonHeader;$/;"	m	struct:TString::__anon4
CommonHeader	src/lobject.h	/^    CommonHeader;$/;"	m	struct:Udata::__anon5
CommonHeader	src/lobject.h	/^  CommonHeader;$/;"	m	struct:GCheader
CommonHeader	src/lobject.h	/^  CommonHeader;$/;"	m	struct:Proto
CommonHeader	src/lobject.h	/^  CommonHeader;$/;"	m	struct:Table
CommonHeader	src/lobject.h	/^  CommonHeader;$/;"	m	struct:UpVal
CommonHeader	src/lobject.h	/^#define CommonHeader	/;"	d
GCObject	src/lobject.h	/^typedef union GCObject GCObject;$/;"	t	typeref:union:GCObject
GCheader	src/lobject.h	/^typedef struct GCheader {$/;"	s
GCheader	src/lobject.h	/^} GCheader;$/;"	t	typeref:struct:GCheader
LAST_TAG	src/lobject.h	/^#define LAST_TAG	/;"	d
LClosure	src/lobject.h	/^typedef struct LClosure {$/;"	s
LClosure	src/lobject.h	/^} LClosure;$/;"	t	typeref:struct:LClosure
LUA_TDEADKEY	src/lobject.h	/^#define LUA_TDEADKEY	/;"	d
LUA_TPROTO	src/lobject.h	/^#define LUA_TPROTO	/;"	d
LUA_TUPVAL	src/lobject.h	/^#define LUA_TUPVAL	/;"	d
LocVar	src/lobject.h	/^typedef struct LocVar {$/;"	s
LocVar	src/lobject.h	/^} LocVar;$/;"	t	typeref:struct:LocVar
NUM_TAGS	src/lobject.h	/^#define NUM_TAGS	/;"	d
Node	src/lobject.h	/^typedef struct Node {$/;"	s
Node	src/lobject.h	/^} Node;$/;"	t	typeref:struct:Node
Proto	src/lobject.h	/^typedef struct Proto {$/;"	s
Proto	src/lobject.h	/^} Proto;$/;"	t	typeref:struct:Proto
StkId	src/lobject.h	/^typedef TValue *StkId;  \/* index to stack elements *\/$/;"	t
TKey	src/lobject.h	/^typedef union TKey {$/;"	u
TKey	src/lobject.h	/^} TKey;$/;"	t	typeref:union:TKey
TString	src/lobject.h	/^typedef union TString {$/;"	u
TString	src/lobject.h	/^} TString;$/;"	t	typeref:union:TString
TValue	src/lobject.h	/^} TValue;$/;"	t	typeref:struct:lua_TValue
TValuefields	src/lobject.h	/^    TValuefields;$/;"	m	struct:TKey::__anon8
TValuefields	src/lobject.h	/^  TValuefields;$/;"	m	struct:lua_TValue
TValuefields	src/lobject.h	/^#define TValuefields	/;"	d
Table	src/lobject.h	/^typedef struct Table {$/;"	s
Table	src/lobject.h	/^} Table;$/;"	t	typeref:struct:Table
Udata	src/lobject.h	/^typedef union Udata {$/;"	u
Udata	src/lobject.h	/^} Udata;$/;"	t	typeref:union:Udata
UpVal	src/lobject.h	/^typedef struct UpVal {$/;"	s
UpVal	src/lobject.h	/^} UpVal;$/;"	t	typeref:struct:UpVal
VARARG_HASARG	src/lobject.h	/^#define VARARG_HASARG	/;"	d
VARARG_ISVARARG	src/lobject.h	/^#define VARARG_ISVARARG	/;"	d
VARARG_NEEDSARG	src/lobject.h	/^#define VARARG_NEEDSARG	/;"	d
Value	src/lobject.h	/^} Value;$/;"	t	typeref:union:__anon3
array	src/lobject.h	/^  TValue *array;  \/* array part *\/$/;"	m	struct:Table
b	src/lobject.h	/^  int b;$/;"	m	union:__anon3
bvalue	src/lobject.h	/^#define bvalue(/;"	d
c	src/lobject.h	/^  CClosure c;$/;"	m	union:Closure
ceillog2	src/lobject.h	/^#define ceillog2(/;"	d
checkconsistency	src/lobject.h	/^#define checkconsistency(/;"	d
checkliveness	src/lobject.h	/^#define checkliveness(/;"	d
clvalue	src/lobject.h	/^#define clvalue(/;"	d
code	src/lobject.h	/^  Instruction *code;$/;"	m	struct:Proto
dummy	src/lobject.h	/^  L_Umaxalign dummy;  \/* ensures maximum alignment for `local' udata *\/$/;"	m	union:Udata
dummy	src/lobject.h	/^  L_Umaxalign dummy;  \/* ensures maximum alignment for strings *\/$/;"	m	union:TString
endpc	src/lobject.h	/^  int endpc;    \/* first point where variable is dead *\/$/;"	m	struct:LocVar
env	src/lobject.h	/^    struct Table *env;$/;"	m	struct:Udata::__anon5	typeref:struct:Udata::__anon5::Table
f	src/lobject.h	/^  lua_CFunction f;$/;"	m	struct:CClosure
flags	src/lobject.h	/^  lu_byte flags;  \/* 1<<p means tagmethod(p) is not present *\/ $/;"	m	struct:Table
gc	src/lobject.h	/^  GCObject *gc;$/;"	m	union:__anon3
gclist	src/lobject.h	/^  GCObject *gclist;$/;"	m	struct:Proto
gclist	src/lobject.h	/^  GCObject *gclist;$/;"	m	struct:Table
gcvalue	src/lobject.h	/^#define gcvalue(/;"	d
getstr	src/lobject.h	/^#define getstr(/;"	d
hash	src/lobject.h	/^    unsigned int hash;$/;"	m	struct:TString::__anon4
hvalue	src/lobject.h	/^#define hvalue(/;"	d
i_key	src/lobject.h	/^  TKey i_key;$/;"	m	struct:Node
i_val	src/lobject.h	/^  TValue i_val;$/;"	m	struct:Node
isLfunction	src/lobject.h	/^#define isLfunction(/;"	d
is_vararg	src/lobject.h	/^  lu_byte is_vararg;$/;"	m	struct:Proto
iscfunction	src/lobject.h	/^#define iscfunction(/;"	d
iscollectable	src/lobject.h	/^#define iscollectable(/;"	d
k	src/lobject.h	/^  TValue *k;  \/* constants used by the function *\/$/;"	m	struct:Proto
l	src/lobject.h	/^    } l;$/;"	m	union:UpVal::__anon6	typeref:struct:UpVal::__anon6::__anon7
l	src/lobject.h	/^  LClosure l;$/;"	m	union:Closure
l_isfalse	src/lobject.h	/^#define l_isfalse(/;"	d
lastfree	src/lobject.h	/^  Node *lastfree;  \/* any free position is before this position *\/$/;"	m	struct:Table
lastlinedefined	src/lobject.h	/^  int lastlinedefined;$/;"	m	struct:Proto
len	src/lobject.h	/^    size_t len;$/;"	m	struct:TString::__anon4
len	src/lobject.h	/^    size_t len;$/;"	m	struct:Udata::__anon5
linedefined	src/lobject.h	/^  int linedefined;$/;"	m	struct:Proto
lineinfo	src/lobject.h	/^  int *lineinfo;  \/* map from opcodes to source lines *\/$/;"	m	struct:Proto
lmod	src/lobject.h	/^#define lmod(/;"	d
lobject_h	src/lobject.h	/^#define lobject_h$/;"	d
locvars	src/lobject.h	/^  struct LocVar *locvars;  \/* information about local variables *\/$/;"	m	struct:Proto	typeref:struct:Proto::LocVar
lsizenode	src/lobject.h	/^  lu_byte lsizenode;  \/* log2 of size of `node' array *\/$/;"	m	struct:Table
luaO_nilobject	src/lobject.h	/^#define luaO_nilobject	/;"	d
luaO_nilobject_	src/lobject.h	/^LUAI_DATA const TValue luaO_nilobject_;$/;"	v
lua_TValue	src/lobject.h	/^typedef struct lua_TValue {$/;"	s
maxstacksize	src/lobject.h	/^  lu_byte maxstacksize;$/;"	m	struct:Proto
metatable	src/lobject.h	/^    struct Table *metatable;$/;"	m	struct:Udata::__anon5	typeref:struct:Udata::__anon5::Table
metatable	src/lobject.h	/^  struct Table *metatable;$/;"	m	struct:Table	typeref:struct:Table::Table
n	src/lobject.h	/^  lua_Number n;$/;"	m	union:__anon3
next	src/lobject.h	/^      struct UpVal *next;$/;"	m	struct:UpVal::__anon6::__anon7	typeref:struct:UpVal::__anon6::__anon7::UpVal
next	src/lobject.h	/^    struct Node *next;  \/* for chaining *\/$/;"	m	struct:TKey::__anon8	typeref:struct:TKey::__anon8::Node
nk	src/lobject.h	/^  } nk;$/;"	m	union:TKey	typeref:struct:TKey::__anon8
node	src/lobject.h	/^  Node *node;$/;"	m	struct:Table
numparams	src/lobject.h	/^  lu_byte numparams;$/;"	m	struct:Proto
nups	src/lobject.h	/^  lu_byte nups;  \/* number of upvalues *\/$/;"	m	struct:Proto
nvalue	src/lobject.h	/^#define nvalue(/;"	d
p	src/lobject.h	/^  struct Proto **p;  \/* functions defined inside the function *\/$/;"	m	struct:Proto	typeref:struct:Proto::Proto
p	src/lobject.h	/^  struct Proto *p;$/;"	m	struct:LClosure	typeref:struct:LClosure::Proto
p	src/lobject.h	/^  void *p;$/;"	m	union:__anon3
prev	src/lobject.h	/^      struct UpVal *prev;$/;"	m	struct:UpVal::__anon6::__anon7	typeref:struct:UpVal::__anon6::__anon7::UpVal
pvalue	src/lobject.h	/^#define pvalue(/;"	d
rawtsvalue	src/lobject.h	/^#define rawtsvalue(/;"	d
rawuvalue	src/lobject.h	/^#define rawuvalue(/;"	d
reserved	src/lobject.h	/^    lu_byte reserved;$/;"	m	struct:TString::__anon4
setbvalue	src/lobject.h	/^#define setbvalue(/;"	d
setclvalue	src/lobject.h	/^#define setclvalue(/;"	d
sethvalue	src/lobject.h	/^#define sethvalue(/;"	d
sethvalue2s	src/lobject.h	/^#define sethvalue2s	/;"	d
setnilvalue	src/lobject.h	/^#define setnilvalue(/;"	d
setnvalue	src/lobject.h	/^#define setnvalue(/;"	d
setobj	src/lobject.h	/^#define setobj(/;"	d
setobj2n	src/lobject.h	/^#define setobj2n	/;"	d
setobj2s	src/lobject.h	/^#define setobj2s	/;"	d
setobj2t	src/lobject.h	/^#define setobj2t	/;"	d
setobjs2s	src/lobject.h	/^#define setobjs2s	/;"	d
setobjt2t	src/lobject.h	/^#define setobjt2t	/;"	d
setptvalue	src/lobject.h	/^#define setptvalue(/;"	d
setptvalue2s	src/lobject.h	/^#define setptvalue2s	/;"	d
setpvalue	src/lobject.h	/^#define setpvalue(/;"	d
setsvalue	src/lobject.h	/^#define setsvalue(/;"	d
setsvalue2n	src/lobject.h	/^#define setsvalue2n	/;"	d
setsvalue2s	src/lobject.h	/^#define setsvalue2s	/;"	d
setthvalue	src/lobject.h	/^#define setthvalue(/;"	d
setttype	src/lobject.h	/^#define setttype(/;"	d
setuvalue	src/lobject.h	/^#define setuvalue(/;"	d
sizearray	src/lobject.h	/^  int sizearray;  \/* size of `array' array *\/$/;"	m	struct:Table
sizecode	src/lobject.h	/^  int sizecode;$/;"	m	struct:Proto
sizek	src/lobject.h	/^  int sizek;  \/* size of `k' *\/$/;"	m	struct:Proto
sizelineinfo	src/lobject.h	/^  int sizelineinfo;$/;"	m	struct:Proto
sizelocvars	src/lobject.h	/^  int sizelocvars;$/;"	m	struct:Proto
sizenode	src/lobject.h	/^#define sizenode(/;"	d
sizep	src/lobject.h	/^  int sizep;  \/* size of `p' *\/$/;"	m	struct:Proto
sizeupvalues	src/lobject.h	/^  int sizeupvalues;$/;"	m	struct:Proto
source	src/lobject.h	/^  TString  *source;$/;"	m	struct:Proto
startpc	src/lobject.h	/^  int startpc;  \/* first point where variable is active *\/$/;"	m	struct:LocVar
svalue	src/lobject.h	/^#define svalue(/;"	d
thvalue	src/lobject.h	/^#define thvalue(/;"	d
tsv	src/lobject.h	/^  } tsv;$/;"	m	union:TString	typeref:struct:TString::__anon4
tsvalue	src/lobject.h	/^#define tsvalue(/;"	d
ttisboolean	src/lobject.h	/^#define ttisboolean(/;"	d
ttisfunction	src/lobject.h	/^#define ttisfunction(/;"	d
ttislightuserdata	src/lobject.h	/^#define ttislightuserdata(/;"	d
ttisnil	src/lobject.h	/^#define ttisnil(/;"	d
ttisnumber	src/lobject.h	/^#define ttisnumber(/;"	d
ttisstring	src/lobject.h	/^#define ttisstring(/;"	d
ttistable	src/lobject.h	/^#define ttistable(/;"	d
ttisthread	src/lobject.h	/^#define ttisthread(/;"	d
ttisuserdata	src/lobject.h	/^#define ttisuserdata(/;"	d
ttype	src/lobject.h	/^#define ttype(/;"	d
tvk	src/lobject.h	/^  TValue tvk;$/;"	m	union:TKey
twoto	src/lobject.h	/^#define twoto(/;"	d
u	src/lobject.h	/^  } u;$/;"	m	struct:UpVal	typeref:union:UpVal::__anon6
upvals	src/lobject.h	/^  UpVal *upvals[1];$/;"	m	struct:LClosure
upvalue	src/lobject.h	/^  TValue upvalue[1];$/;"	m	struct:CClosure
upvalues	src/lobject.h	/^  TString **upvalues;  \/* upvalue names *\/$/;"	m	struct:Proto
uv	src/lobject.h	/^  } uv;$/;"	m	union:Udata	typeref:struct:Udata::__anon5
uvalue	src/lobject.h	/^#define uvalue(/;"	d
v	src/lobject.h	/^  TValue *v;  \/* points to stack or to its own value *\/$/;"	m	struct:UpVal
value	src/lobject.h	/^    TValue value;  \/* the value (when closed) *\/$/;"	m	union:UpVal::__anon6
varname	src/lobject.h	/^  TString *varname;$/;"	m	struct:LocVar
LUA_CORE	src/lopcodes.c	/^#define LUA_CORE$/;"	d	file:
lopcodes_c	src/lopcodes.c	/^#define lopcodes_c$/;"	d	file:
luaP_opmodes	src/lopcodes.c	/^const lu_byte luaP_opmodes[NUM_OPCODES] = {$/;"	v
luaP_opnames	src/lopcodes.c	/^const char *const luaP_opnames[NUM_OPCODES+1] = {$/;"	v
opmode	src/lopcodes.c	/^#define opmode(/;"	d	file:
BITRK	src/lopcodes.h	/^#define BITRK	/;"	d
CREATE_ABC	src/lopcodes.h	/^#define CREATE_ABC(/;"	d
CREATE_ABx	src/lopcodes.h	/^#define CREATE_ABx(/;"	d
GETARG_A	src/lopcodes.h	/^#define GETARG_A(/;"	d
GETARG_B	src/lopcodes.h	/^#define GETARG_B(/;"	d
GETARG_Bx	src/lopcodes.h	/^#define GETARG_Bx(/;"	d
GETARG_C	src/lopcodes.h	/^#define GETARG_C(/;"	d
GETARG_sBx	src/lopcodes.h	/^#define GETARG_sBx(/;"	d
GET_OPCODE	src/lopcodes.h	/^#define GET_OPCODE(/;"	d
INDEXK	src/lopcodes.h	/^#define INDEXK(/;"	d
ISK	src/lopcodes.h	/^#define ISK(/;"	d
LFIELDS_PER_FLUSH	src/lopcodes.h	/^#define LFIELDS_PER_FLUSH	/;"	d
MASK0	src/lopcodes.h	/^#define MASK0(/;"	d
MASK1	src/lopcodes.h	/^#define MASK1(/;"	d
MAXARG_A	src/lopcodes.h	/^#define MAXARG_A /;"	d
MAXARG_B	src/lopcodes.h	/^#define MAXARG_B /;"	d
MAXARG_Bx	src/lopcodes.h	/^#define MAXARG_Bx /;"	d
MAXARG_C	src/lopcodes.h	/^#define MAXARG_C /;"	d
MAXARG_sBx	src/lopcodes.h	/^#define MAXARG_sBx /;"	d
MAXINDEXRK	src/lopcodes.h	/^#define MAXINDEXRK	/;"	d
NO_REG	src/lopcodes.h	/^#define NO_REG	/;"	d
NUM_OPCODES	src/lopcodes.h	/^#define NUM_OPCODES	/;"	d
OP_ADD	src/lopcodes.h	/^OP_ADD,\/*	A B C	R(A) := RK(B) + RK(C)				*\/$/;"	e	enum:__anon9
OP_CALL	src/lopcodes.h	/^OP_CALL,\/*	A B C	R(A), ... ,R(A+C-2) := R(A)(R(A+1), ... ,R(A+B-1)) *\/$/;"	e	enum:__anon9
OP_CLOSE	src/lopcodes.h	/^OP_CLOSE,\/*	A 	close all variables in the stack up to (>=) R(A)*\/$/;"	e	enum:__anon9
OP_CLOSURE	src/lopcodes.h	/^OP_CLOSURE,\/*	A Bx	R(A) := closure(KPROTO[Bx], R(A), ... ,R(A+n))	*\/$/;"	e	enum:__anon9
OP_CONCAT	src/lopcodes.h	/^OP_CONCAT,\/*	A B C	R(A) := R(B).. ... ..R(C)			*\/$/;"	e	enum:__anon9
OP_DIV	src/lopcodes.h	/^OP_DIV,\/*	A B C	R(A) := RK(B) \/ RK(C)				*\/$/;"	e	enum:__anon9
OP_EQ	src/lopcodes.h	/^OP_EQ,\/*	A B C	if ((RK(B) == RK(C)) ~= A) then pc++		*\/$/;"	e	enum:__anon9
OP_FORLOOP	src/lopcodes.h	/^OP_FORLOOP,\/*	A sBx	R(A)+=R(A+2);$/;"	e	enum:__anon9
OP_FORPREP	src/lopcodes.h	/^OP_FORPREP,\/*	A sBx	R(A)-=R(A+2); pc+=sBx				*\/$/;"	e	enum:__anon9
OP_GETGLOBAL	src/lopcodes.h	/^OP_GETGLOBAL,\/*	A Bx	R(A) := Gbl[Kst(Bx)]				*\/$/;"	e	enum:__anon9
OP_GETTABLE	src/lopcodes.h	/^OP_GETTABLE,\/*	A B C	R(A) := R(B)[RK(C)]				*\/$/;"	e	enum:__anon9
OP_GETUPVAL	src/lopcodes.h	/^OP_GETUPVAL,\/*	A B	R(A) := UpValue[B]				*\/$/;"	e	enum:__anon9
OP_JMP	src/lopcodes.h	/^OP_JMP,\/*	sBx	pc+=sBx					*\/$/;"	e	enum:__anon9
OP_LE	src/lopcodes.h	/^OP_LE,\/*	A B C	if ((RK(B) <= RK(C)) ~= A) then pc++  		*\/$/;"	e	enum:__anon9
OP_LEN	src/lopcodes.h	/^OP_LEN,\/*	A B	R(A) := length of R(B)				*\/$/;"	e	enum:__anon9
OP_LOADBOOL	src/lopcodes.h	/^OP_LOADBOOL,\/*	A B C	R(A) := (Bool)B; if (C) pc++			*\/$/;"	e	enum:__anon9
OP_LOADK	src/lopcodes.h	/^OP_LOADK,\/*	A Bx	R(A) := Kst(Bx)					*\/$/;"	e	enum:__anon9
OP_LOADNIL	src/lopcodes.h	/^OP_LOADNIL,\/*	A B	R(A) := ... := R(B) := nil			*\/$/;"	e	enum:__anon9
OP_LT	src/lopcodes.h	/^OP_LT,\/*	A B C	if ((RK(B) <  RK(C)) ~= A) then pc++  		*\/$/;"	e	enum:__anon9
OP_MOD	src/lopcodes.h	/^OP_MOD,\/*	A B C	R(A) := RK(B) % RK(C)				*\/$/;"	e	enum:__anon9
OP_MOVE	src/lopcodes.h	/^OP_MOVE,\/*	A B	R(A) := R(B)					*\/$/;"	e	enum:__anon9
OP_MUL	src/lopcodes.h	/^OP_MUL,\/*	A B C	R(A) := RK(B) * RK(C)				*\/$/;"	e	enum:__anon9
OP_NEWTABLE	src/lopcodes.h	/^OP_NEWTABLE,\/*	A B C	R(A) := {} (size = B,C)				*\/$/;"	e	enum:__anon9
OP_NOT	src/lopcodes.h	/^OP_NOT,\/*	A B	R(A) := not R(B)				*\/$/;"	e	enum:__anon9
OP_POW	src/lopcodes.h	/^OP_POW,\/*	A B C	R(A) := RK(B) ^ RK(C)				*\/$/;"	e	enum:__anon9
OP_RETURN	src/lopcodes.h	/^OP_RETURN,\/*	A B	return R(A), ... ,R(A+B-2)	(see note)	*\/$/;"	e	enum:__anon9
OP_SELF	src/lopcodes.h	/^OP_SELF,\/*	A B C	R(A+1) := R(B); R(A) := R(B)[RK(C)]		*\/$/;"	e	enum:__anon9
OP_SETGLOBAL	src/lopcodes.h	/^OP_SETGLOBAL,\/*	A Bx	Gbl[Kst(Bx)] := R(A)				*\/$/;"	e	enum:__anon9
OP_SETLIST	src/lopcodes.h	/^OP_SETLIST,\/*	A B C	R(A)[(C-1)*FPF+i] := R(A+i), 1 <= i <= B	*\/$/;"	e	enum:__anon9
OP_SETTABLE	src/lopcodes.h	/^OP_SETTABLE,\/*	A B C	R(A)[RK(B)] := RK(C)				*\/$/;"	e	enum:__anon9
OP_SETUPVAL	src/lopcodes.h	/^OP_SETUPVAL,\/*	A B	UpValue[B] := R(A)				*\/$/;"	e	enum:__anon9
OP_SUB	src/lopcodes.h	/^OP_SUB,\/*	A B C	R(A) := RK(B) - RK(C)				*\/$/;"	e	enum:__anon9
OP_TAILCALL	src/lopcodes.h	/^OP_TAILCALL,\/*	A B C	return R(A)(R(A+1), ... ,R(A+B-1))		*\/$/;"	e	enum:__anon9
OP_TEST	src/lopcodes.h	/^OP_TEST,\/*	A C	if not (R(A) <=> C) then pc++			*\/ $/;"	e	enum:__anon9
OP_TESTSET	src/lopcodes.h	/^OP_TESTSET,\/*	A B C	if (R(B) <=> C) then R(A) := R(B) else pc++	*\/ $/;"	e	enum:__anon9
OP_TFORLOOP	src/lopcodes.h	/^OP_TFORLOOP,\/*	A C	R(A+3), ... ,R(A+2+C) := R(A)(R(A+1), R(A+2)); $/;"	e	enum:__anon9
OP_UNM	src/lopcodes.h	/^OP_UNM,\/*	A B	R(A) := -R(B)					*\/$/;"	e	enum:__anon9
OP_VARARG	src/lopcodes.h	/^OP_VARARG\/*	A B	R(A), R(A+1), ..., R(A+B-1) = vararg		*\/$/;"	e	enum:__anon9
OpArgK	src/lopcodes.h	/^  OpArgK   \/* argument is a constant or register\/constant *\/$/;"	e	enum:OpArgMask
OpArgMask	src/lopcodes.h	/^enum OpArgMask {$/;"	g
OpArgN	src/lopcodes.h	/^  OpArgN,  \/* argument is not used *\/$/;"	e	enum:OpArgMask
OpArgR	src/lopcodes.h	/^  OpArgR,  \/* argument is a register or a jump offset *\/$/;"	e	enum:OpArgMask
OpArgU	src/lopcodes.h	/^  OpArgU,  \/* argument is used *\/$/;"	e	enum:OpArgMask
OpCode	src/lopcodes.h	/^} OpCode;$/;"	t	typeref:enum:__anon9
OpMode	src/lopcodes.h	/^enum OpMode {iABC, iABx, iAsBx};  \/* basic instruction format *\/$/;"	g
POS_A	src/lopcodes.h	/^#define POS_A	/;"	d
POS_B	src/lopcodes.h	/^#define POS_B	/;"	d
POS_Bx	src/lopcodes.h	/^#define POS_Bx	/;"	d
POS_C	src/lopcodes.h	/^#define POS_C	/;"	d
POS_OP	src/lopcodes.h	/^#define POS_OP	/;"	d
RKASK	src/lopcodes.h	/^#define RKASK(/;"	d
SETARG_A	src/lopcodes.h	/^#define SETARG_A(/;"	d
SETARG_B	src/lopcodes.h	/^#define SETARG_B(/;"	d
SETARG_Bx	src/lopcodes.h	/^#define SETARG_Bx(/;"	d
SETARG_C	src/lopcodes.h	/^#define SETARG_C(/;"	d
SETARG_sBx	src/lopcodes.h	/^#define SETARG_sBx(/;"	d
SET_OPCODE	src/lopcodes.h	/^#define SET_OPCODE(/;"	d
SIZE_A	src/lopcodes.h	/^#define SIZE_A	/;"	d
SIZE_B	src/lopcodes.h	/^#define SIZE_B	/;"	d
SIZE_Bx	src/lopcodes.h	/^#define SIZE_Bx	/;"	d
SIZE_C	src/lopcodes.h	/^#define SIZE_C	/;"	d
SIZE_OP	src/lopcodes.h	/^#define SIZE_OP	/;"	d
getBMode	src/lopcodes.h	/^#define getBMode(/;"	d
getCMode	src/lopcodes.h	/^#define getCMode(/;"	d
getOpMode	src/lopcodes.h	/^#define getOpMode(/;"	d
iABC	src/lopcodes.h	/^enum OpMode {iABC, iABx, iAsBx};  \/* basic instruction format *\/$/;"	e	enum:OpMode
iABx	src/lopcodes.h	/^enum OpMode {iABC, iABx, iAsBx};  \/* basic instruction format *\/$/;"	e	enum:OpMode
iAsBx	src/lopcodes.h	/^enum OpMode {iABC, iABx, iAsBx};  \/* basic instruction format *\/$/;"	e	enum:OpMode
lopcodes_h	src/lopcodes.h	/^#define lopcodes_h$/;"	d
luaP_opmodes	src/lopcodes.h	/^LUAI_DATA const lu_byte luaP_opmodes[NUM_OPCODES];$/;"	v
luaP_opnames	src/lopcodes.h	/^LUAI_DATA const char *const luaP_opnames[NUM_OPCODES+1];  \/* opcode names *\/$/;"	v
testAMode	src/lopcodes.h	/^#define testAMode(/;"	d
testTMode	src/lopcodes.h	/^#define testTMode(/;"	d
LUA_LIB	src/loslib.c	/^#define LUA_LIB$/;"	d	file:
getboolfield	src/loslib.c	/^static int getboolfield (lua_State *L, const char *key) {$/;"	f	file:
getfield	src/loslib.c	/^static int getfield (lua_State *L, const char *key, int d) {$/;"	f	file:
loslib_c	src/loslib.c	/^#define loslib_c$/;"	d	file:
luaopen_os	src/loslib.c	/^LUALIB_API int luaopen_os (lua_State *L) {$/;"	f
os_clock	src/loslib.c	/^static int os_clock (lua_State *L) {$/;"	f	file:
os_date	src/loslib.c	/^static int os_date (lua_State *L) {$/;"	f	file:
os_difftime	src/loslib.c	/^static int os_difftime (lua_State *L) {$/;"	f	file:
os_execute	src/loslib.c	/^static int os_execute (lua_State *L) {$/;"	f	file:
os_exit	src/loslib.c	/^static int os_exit (lua_State *L) {$/;"	f	file:
os_getenv	src/loslib.c	/^static int os_getenv (lua_State *L) {$/;"	f	file:
os_pushresult	src/loslib.c	/^static int os_pushresult (lua_State *L, int i, const char *filename) {$/;"	f	file:
os_remove	src/loslib.c	/^static int os_remove (lua_State *L) {$/;"	f	file:
os_rename	src/loslib.c	/^static int os_rename (lua_State *L) {$/;"	f	file:
os_setlocale	src/loslib.c	/^static int os_setlocale (lua_State *L) {$/;"	f	file:
os_time	src/loslib.c	/^static int os_time (lua_State *L) {$/;"	f	file:
os_tmpname	src/loslib.c	/^static int os_tmpname (lua_State *L) {$/;"	f	file:
setboolfield	src/loslib.c	/^static void setboolfield (lua_State *L, const char *key, int value) {$/;"	f	file:
setfield	src/loslib.c	/^static void setfield (lua_State *L, const char *key, int value) {$/;"	f	file:
syslib	src/loslib.c	/^static const luaL_Reg syslib[] = {$/;"	v	file:
BlockCnt	src/lparser.c	/^typedef struct BlockCnt {$/;"	s	file:
BlockCnt	src/lparser.c	/^} BlockCnt;$/;"	t	typeref:struct:BlockCnt	file:
ConsControl	src/lparser.c	/^struct ConsControl {$/;"	s	file:
LHS_assign	src/lparser.c	/^struct LHS_assign {$/;"	s	file:
LUA_CORE	src/lparser.c	/^#define LUA_CORE$/;"	d	file:
UNARY_PRIORITY	src/lparser.c	/^#define UNARY_PRIORITY	/;"	d	file:
adjust_assign	src/lparser.c	/^static void adjust_assign (LexState *ls, int nvars, int nexps, expdesc *e) {$/;"	f	file:
adjustlocalvars	src/lparser.c	/^static void adjustlocalvars (LexState *ls, int nvars) {$/;"	f	file:
anchor_token	src/lparser.c	/^static void anchor_token (LexState *ls) {$/;"	f	file:
assignment	src/lparser.c	/^static void assignment (LexState *ls, struct LHS_assign *lh, int nvars) {$/;"	f	file:
block	src/lparser.c	/^static void block (LexState *ls) {$/;"	f	file:
block_follow	src/lparser.c	/^static int block_follow (int token) {$/;"	f	file:
body	src/lparser.c	/^static void body (LexState *ls, expdesc *e, int needself, int line) {$/;"	f	file:
breaklist	src/lparser.c	/^  int breaklist;  \/* list of jumps out of this loop *\/$/;"	m	struct:BlockCnt	file:
breakstat	src/lparser.c	/^static void breakstat (LexState *ls) {$/;"	f	file:
check	src/lparser.c	/^static void check (LexState *ls, int c) {$/;"	f	file:
check_condition	src/lparser.c	/^#define check_condition(/;"	d	file:
check_conflict	src/lparser.c	/^static void check_conflict (LexState *ls, struct LHS_assign *lh, expdesc *v) {$/;"	f	file:
check_match	src/lparser.c	/^static void check_match (LexState *ls, int what, int who, int where) {$/;"	f	file:
checkname	src/lparser.c	/^static void checkname(LexState *ls, expdesc *e) {$/;"	f	file:
checknext	src/lparser.c	/^static void checknext (LexState *ls, int c) {$/;"	f	file:
chunk	src/lparser.c	/^static void chunk (LexState *ls) {$/;"	f	file:
close_func	src/lparser.c	/^static void close_func (LexState *ls) {$/;"	f	file:
closelistfield	src/lparser.c	/^static void closelistfield (FuncState *fs, struct ConsControl *cc) {$/;"	f	file:
codestring	src/lparser.c	/^static void codestring (LexState *ls, expdesc *e, TString *s) {$/;"	f	file:
cond	src/lparser.c	/^static int cond (LexState *ls) {$/;"	f	file:
constructor	src/lparser.c	/^static void constructor (LexState *ls, expdesc *t) {$/;"	f	file:
enterblock	src/lparser.c	/^static void enterblock (FuncState *fs, BlockCnt *bl, lu_byte isbreakable) {$/;"	f	file:
enterlevel	src/lparser.c	/^static void enterlevel (LexState *ls) {$/;"	f	file:
error_expected	src/lparser.c	/^static void error_expected (LexState *ls, int token) {$/;"	f	file:
errorlimit	src/lparser.c	/^static void errorlimit (FuncState *fs, int limit, const char *what) {$/;"	f	file:
exp1	src/lparser.c	/^static int exp1 (LexState *ls) {$/;"	f	file:
explist1	src/lparser.c	/^static int explist1 (LexState *ls, expdesc *v) {$/;"	f	file:
expr	src/lparser.c	/^static void expr (LexState *ls, expdesc *v) {$/;"	f	file:
exprstat	src/lparser.c	/^static void exprstat (LexState *ls) {$/;"	f	file:
field	src/lparser.c	/^static void field (LexState *ls, expdesc *v) {$/;"	f	file:
forbody	src/lparser.c	/^static void forbody (LexState *ls, int base, int line, int nvars, int isnum) {$/;"	f	file:
forlist	src/lparser.c	/^static void forlist (LexState *ls, TString *indexname) {$/;"	f	file:
fornum	src/lparser.c	/^static void fornum (LexState *ls, TString *varname, int line) {$/;"	f	file:
forstat	src/lparser.c	/^static void forstat (LexState *ls, int line) {$/;"	f	file:
funcargs	src/lparser.c	/^static void funcargs (LexState *ls, expdesc *f) {$/;"	f	file:
funcname	src/lparser.c	/^static int funcname (LexState *ls, expdesc *v) {$/;"	f	file:
funcstat	src/lparser.c	/^static void funcstat (LexState *ls, int line) {$/;"	f	file:
getbinopr	src/lparser.c	/^static BinOpr getbinopr (int op) {$/;"	f	file:
getlocvar	src/lparser.c	/^#define getlocvar(/;"	d	file:
getunopr	src/lparser.c	/^static UnOpr getunopr (int op) {$/;"	f	file:
hasmultret	src/lparser.c	/^#define hasmultret(/;"	d	file:
ifstat	src/lparser.c	/^static void ifstat (LexState *ls, int line) {$/;"	f	file:
indexupvalue	src/lparser.c	/^static int indexupvalue (FuncState *fs, TString *name, expdesc *v) {$/;"	f	file:
init_exp	src/lparser.c	/^static void init_exp (expdesc *e, expkind k, int i) {$/;"	f	file:
isbreakable	src/lparser.c	/^  lu_byte isbreakable;  \/* true if `block' is a loop *\/$/;"	m	struct:BlockCnt	file:
lastlistfield	src/lparser.c	/^static void lastlistfield (FuncState *fs, struct ConsControl *cc) {$/;"	f	file:
leaveblock	src/lparser.c	/^static void leaveblock (FuncState *fs) {$/;"	f	file:
leavelevel	src/lparser.c	/^#define leavelevel(/;"	d	file:
left	src/lparser.c	/^  lu_byte left;  \/* left priority for each binary operator *\/$/;"	m	struct:__anon10	file:
listfield	src/lparser.c	/^static void listfield (LexState *ls, struct ConsControl *cc) {$/;"	f	file:
localfunc	src/lparser.c	/^static void localfunc (LexState *ls) {$/;"	f	file:
localstat	src/lparser.c	/^static void localstat (LexState *ls) {$/;"	f	file:
lparser_c	src/lparser.c	/^#define lparser_c$/;"	d	file:
luaY_checklimit	src/lparser.c	/^#define luaY_checklimit(/;"	d	file:
luaY_parser	src/lparser.c	/^Proto *luaY_parser (lua_State *L, ZIO *z, Mbuffer *buff, const char *name) {$/;"	f
markupval	src/lparser.c	/^static void markupval (FuncState *fs, int level) {$/;"	f	file:
na	src/lparser.c	/^  int na;  \/* total number of array elements *\/$/;"	m	struct:ConsControl	file:
nactvar	src/lparser.c	/^  lu_byte nactvar;  \/* # active locals outside the breakable structure *\/$/;"	m	struct:BlockCnt	file:
new_localvar	src/lparser.c	/^static void new_localvar (LexState *ls, TString *name, int n) {$/;"	f	file:
new_localvarliteral	src/lparser.c	/^#define new_localvarliteral(/;"	d	file:
nh	src/lparser.c	/^  int nh;  \/* total number of `record' elements *\/$/;"	m	struct:ConsControl	file:
open_func	src/lparser.c	/^static void open_func (LexState *ls, FuncState *fs) {$/;"	f	file:
parlist	src/lparser.c	/^static void parlist (LexState *ls) {$/;"	f	file:
prefixexp	src/lparser.c	/^static void prefixexp (LexState *ls, expdesc *v) {$/;"	f	file:
prev	src/lparser.c	/^  struct LHS_assign *prev;$/;"	m	struct:LHS_assign	typeref:struct:LHS_assign::LHS_assign	file:
previous	src/lparser.c	/^  struct BlockCnt *previous;  \/* chain *\/$/;"	m	struct:BlockCnt	typeref:struct:BlockCnt::BlockCnt	file:
primaryexp	src/lparser.c	/^static void primaryexp (LexState *ls, expdesc *v) {$/;"	f	file:
priority	src/lparser.c	/^} priority[] = {  \/* ORDER OPR *\/$/;"	v	typeref:struct:__anon10	file:
pushclosure	src/lparser.c	/^static void pushclosure (LexState *ls, FuncState *func, expdesc *v) {$/;"	f	file:
recfield	src/lparser.c	/^static void recfield (LexState *ls, struct ConsControl *cc) {$/;"	f	file:
registerlocalvar	src/lparser.c	/^static int registerlocalvar (LexState *ls, TString *varname) {$/;"	f	file:
removevars	src/lparser.c	/^static void removevars (LexState *ls, int tolevel) {$/;"	f	file:
repeatstat	src/lparser.c	/^static void repeatstat (LexState *ls, int line) {$/;"	f	file:
retstat	src/lparser.c	/^static void retstat (LexState *ls) {$/;"	f	file:
right	src/lparser.c	/^  lu_byte right; \/* right priority *\/$/;"	m	struct:__anon10	file:
searchvar	src/lparser.c	/^static int searchvar (FuncState *fs, TString *n) {$/;"	f	file:
simpleexp	src/lparser.c	/^static void simpleexp (LexState *ls, expdesc *v) {$/;"	f	file:
singlevar	src/lparser.c	/^static void singlevar (LexState *ls, expdesc *var) {$/;"	f	file:
singlevaraux	src/lparser.c	/^static int singlevaraux (FuncState *fs, TString *n, expdesc *var, int base) {$/;"	f	file:
statement	src/lparser.c	/^static int statement (LexState *ls) {$/;"	f	file:
str_checkname	src/lparser.c	/^static TString *str_checkname (LexState *ls) {$/;"	f	file:
subexpr	src/lparser.c	/^static BinOpr subexpr (LexState *ls, expdesc *v, unsigned int limit) {$/;"	f	file:
t	src/lparser.c	/^  expdesc *t;  \/* table descriptor *\/$/;"	m	struct:ConsControl	file:
test_then_block	src/lparser.c	/^static int test_then_block (LexState *ls) {$/;"	f	file:
testnext	src/lparser.c	/^static int testnext (LexState *ls, int c) {$/;"	f	file:
tostore	src/lparser.c	/^  int tostore;  \/* number of array elements pending to be stored *\/$/;"	m	struct:ConsControl	file:
upval	src/lparser.c	/^  lu_byte upval;  \/* true if some variable in the block is an upvalue *\/$/;"	m	struct:BlockCnt	file:
v	src/lparser.c	/^  expdesc v;  \/* last list item read *\/$/;"	m	struct:ConsControl	file:
v	src/lparser.c	/^  expdesc v;  \/* variable (global, local, upvalue, or indexed) *\/$/;"	m	struct:LHS_assign	file:
whilestat	src/lparser.c	/^static void whilestat (LexState *ls, int line) {$/;"	f	file:
yindex	src/lparser.c	/^static void yindex (LexState *ls, expdesc *v) {$/;"	f	file:
FuncState	src/lparser.h	/^typedef struct FuncState {$/;"	s
FuncState	src/lparser.h	/^} FuncState;$/;"	t	typeref:struct:FuncState
L	src/lparser.h	/^  struct lua_State *L;  \/* copy of the Lua state *\/$/;"	m	struct:FuncState	typeref:struct:FuncState::lua_State
VCALL	src/lparser.h	/^  VCALL,	\/* info = instruction pc *\/$/;"	e	enum:__anon11
VFALSE	src/lparser.h	/^  VFALSE,$/;"	e	enum:__anon11
VGLOBAL	src/lparser.h	/^  VGLOBAL,	\/* info = index of table; aux = index of global name in `k' *\/$/;"	e	enum:__anon11
VINDEXED	src/lparser.h	/^  VINDEXED,	\/* info = table register; aux = index register (or `k') *\/$/;"	e	enum:__anon11
VJMP	src/lparser.h	/^  VJMP,		\/* info = instruction pc *\/$/;"	e	enum:__anon11
VK	src/lparser.h	/^  VK,		\/* info = index of constant in `k' *\/$/;"	e	enum:__anon11
VKNUM	src/lparser.h	/^  VKNUM,	\/* nval = numerical value *\/$/;"	e	enum:__anon11
VLOCAL	src/lparser.h	/^  VLOCAL,	\/* info = local register *\/$/;"	e	enum:__anon11
VNIL	src/lparser.h	/^  VNIL,$/;"	e	enum:__anon11
VNONRELOC	src/lparser.h	/^  VNONRELOC,	\/* info = result register *\/$/;"	e	enum:__anon11
VRELOCABLE	src/lparser.h	/^  VRELOCABLE,	\/* info = instruction pc *\/$/;"	e	enum:__anon11
VTRUE	src/lparser.h	/^  VTRUE,$/;"	e	enum:__anon11
VUPVAL	src/lparser.h	/^  VUPVAL,       \/* info = index of upvalue in `upvalues' *\/$/;"	e	enum:__anon11
VVARARG	src/lparser.h	/^  VVARARG	\/* info = instruction pc *\/$/;"	e	enum:__anon11
VVOID	src/lparser.h	/^  VVOID,	\/* no value *\/$/;"	e	enum:__anon11
actvar	src/lparser.h	/^  unsigned short actvar[LUAI_MAXVARS];  \/* declared-variable stack *\/$/;"	m	struct:FuncState
aux	src/lparser.h	/^    struct { int info, aux; } s;$/;"	m	struct:expdesc::__anon12::__anon13
bl	src/lparser.h	/^  struct BlockCnt *bl;  \/* chain of current blocks *\/$/;"	m	struct:FuncState	typeref:struct:FuncState::BlockCnt
expdesc	src/lparser.h	/^typedef struct expdesc {$/;"	s
expdesc	src/lparser.h	/^} expdesc;$/;"	t	typeref:struct:expdesc
expkind	src/lparser.h	/^} expkind;$/;"	t	typeref:enum:__anon11
f	src/lparser.h	/^  Proto *f;  \/* current function header *\/$/;"	m	struct:FuncState
f	src/lparser.h	/^  int f;  \/* patch list of `exit when false' *\/$/;"	m	struct:expdesc
freereg	src/lparser.h	/^  int freereg;  \/* first free register *\/$/;"	m	struct:FuncState
h	src/lparser.h	/^  Table *h;  \/* table to find (and reuse) elements in `k' *\/$/;"	m	struct:FuncState
info	src/lparser.h	/^    struct { int info, aux; } s;$/;"	m	struct:expdesc::__anon12::__anon13
info	src/lparser.h	/^  lu_byte info;$/;"	m	struct:upvaldesc
jpc	src/lparser.h	/^  int jpc;  \/* list of pending jumps to `pc' *\/$/;"	m	struct:FuncState
k	src/lparser.h	/^  expkind k;$/;"	m	struct:expdesc
k	src/lparser.h	/^  lu_byte k;$/;"	m	struct:upvaldesc
lasttarget	src/lparser.h	/^  int lasttarget;   \/* `pc' of last `jump target' *\/$/;"	m	struct:FuncState
lparser_h	src/lparser.h	/^#define lparser_h$/;"	d
ls	src/lparser.h	/^  struct LexState *ls;  \/* lexical state *\/$/;"	m	struct:FuncState	typeref:struct:FuncState::LexState
nactvar	src/lparser.h	/^  lu_byte nactvar;  \/* number of active local variables *\/$/;"	m	struct:FuncState
nk	src/lparser.h	/^  int nk;  \/* number of elements in `k' *\/$/;"	m	struct:FuncState
nlocvars	src/lparser.h	/^  short nlocvars;  \/* number of elements in `locvars' *\/$/;"	m	struct:FuncState
np	src/lparser.h	/^  int np;  \/* number of elements in `p' *\/$/;"	m	struct:FuncState
nval	src/lparser.h	/^    lua_Number nval;$/;"	m	union:expdesc::__anon12
pc	src/lparser.h	/^  int pc;  \/* next position to code (equivalent to `ncode') *\/$/;"	m	struct:FuncState
prev	src/lparser.h	/^  struct FuncState *prev;  \/* enclosing function *\/$/;"	m	struct:FuncState	typeref:struct:FuncState::FuncState
s	src/lparser.h	/^    struct { int info, aux; } s;$/;"	m	union:expdesc::__anon12	typeref:struct:expdesc::__anon12::__anon13
t	src/lparser.h	/^  int t;  \/* patch list of `exit when true' *\/$/;"	m	struct:expdesc
u	src/lparser.h	/^  } u;$/;"	m	struct:expdesc	typeref:union:expdesc::__anon12
upvaldesc	src/lparser.h	/^typedef struct upvaldesc {$/;"	s
upvaldesc	src/lparser.h	/^} upvaldesc;$/;"	t	typeref:struct:upvaldesc
upvalues	src/lparser.h	/^  upvaldesc upvalues[LUAI_MAXUPVALUES];  \/* upvalues *\/$/;"	m	struct:FuncState
LG	src/lstate.c	/^typedef struct LG {$/;"	s	file:
LG	src/lstate.c	/^} LG;$/;"	t	typeref:struct:LG	file:
LUA_CORE	src/lstate.c	/^#define LUA_CORE$/;"	d	file:
callallgcTM	src/lstate.c	/^static void callallgcTM (lua_State *L, void *ud) {$/;"	f	file:
close_state	src/lstate.c	/^static void close_state (lua_State *L) {$/;"	f	file:
f_luaopen	src/lstate.c	/^static void f_luaopen (lua_State *L, void *ud) {$/;"	f	file:
freestack	src/lstate.c	/^static void freestack (lua_State *L, lua_State *L1) {$/;"	f	file:
fromstate	src/lstate.c	/^#define fromstate(/;"	d	file:
g	src/lstate.c	/^  global_State g;$/;"	m	struct:LG	file:
l	src/lstate.c	/^  lua_State l;$/;"	m	struct:LG	file:
lstate_c	src/lstate.c	/^#define lstate_c$/;"	d	file:
luaE_freethread	src/lstate.c	/^void luaE_freethread (lua_State *L, lua_State *L1) {$/;"	f
luaE_newthread	src/lstate.c	/^lua_State *luaE_newthread (lua_State *L) {$/;"	f
lua_close	src/lstate.c	/^LUA_API void lua_close (lua_State *L) {$/;"	f
lua_newstate	src/lstate.c	/^LUA_API lua_State *lua_newstate (lua_Alloc f, void *ud) {$/;"	f
preinit_state	src/lstate.c	/^static void preinit_state (lua_State *L, global_State *g) {$/;"	f	file:
stack_init	src/lstate.c	/^static void stack_init (lua_State *L1, lua_State *L) {$/;"	f	file:
state_size	src/lstate.c	/^#define state_size(/;"	d	file:
tostate	src/lstate.c	/^#define tostate(/;"	d	file:
BASIC_CI_SIZE	src/lstate.h	/^#define BASIC_CI_SIZE /;"	d
BASIC_STACK_SIZE	src/lstate.h	/^#define BASIC_STACK_SIZE /;"	d
CallInfo	src/lstate.h	/^typedef struct CallInfo {$/;"	s
CallInfo	src/lstate.h	/^} CallInfo;$/;"	t	typeref:struct:CallInfo
CommonHeader	src/lstate.h	/^  CommonHeader;$/;"	m	struct:lua_State
EXTRA_STACK	src/lstate.h	/^#define EXTRA_STACK /;"	d
G	src/lstate.h	/^#define G(/;"	d
GCObject	src/lstate.h	/^union GCObject {$/;"	u
GCthreshold	src/lstate.h	/^  lu_mem GCthreshold;$/;"	m	struct:global_State
allowhook	src/lstate.h	/^  lu_byte allowhook;$/;"	m	struct:lua_State
base	src/lstate.h	/^  StkId base;  \/* base for this function *\/$/;"	m	struct:CallInfo
base	src/lstate.h	/^  StkId base;  \/* base of current function *\/$/;"	m	struct:lua_State
baseCcalls	src/lstate.h	/^  unsigned short baseCcalls;  \/* nested C calls when resuming coroutine *\/$/;"	m	struct:lua_State
base_ci	src/lstate.h	/^  CallInfo *base_ci;  \/* array of CallInfo's *\/$/;"	m	struct:lua_State
basehookcount	src/lstate.h	/^  int basehookcount;$/;"	m	struct:lua_State
buff	src/lstate.h	/^  Mbuffer buff;  \/* temporary buffer for string concatentation *\/$/;"	m	struct:global_State
ci	src/lstate.h	/^  CallInfo *ci;  \/* call info for current function *\/$/;"	m	struct:lua_State
ci_func	src/lstate.h	/^#define ci_func(/;"	d
cl	src/lstate.h	/^  union Closure cl;$/;"	m	union:GCObject	typeref:union:GCObject::Closure
curr_func	src/lstate.h	/^#define curr_func(/;"	d
currentwhite	src/lstate.h	/^  lu_byte currentwhite;$/;"	m	struct:global_State
end_ci	src/lstate.h	/^  CallInfo *end_ci;  \/* points after end of ci array*\/$/;"	m	struct:lua_State
env	src/lstate.h	/^  TValue env;  \/* temporary place for environments *\/$/;"	m	struct:lua_State
errfunc	src/lstate.h	/^  ptrdiff_t errfunc;  \/* current error handling function (stack index) *\/$/;"	m	struct:lua_State
errorJmp	src/lstate.h	/^  struct lua_longjmp *errorJmp;  \/* current error recover point *\/$/;"	m	struct:lua_State	typeref:struct:lua_State::lua_longjmp
estimate	src/lstate.h	/^  lu_mem estimate;  \/* an estimate of number of bytes actually in use *\/$/;"	m	struct:global_State
f_isLua	src/lstate.h	/^#define f_isLua(/;"	d
frealloc	src/lstate.h	/^  lua_Alloc frealloc;  \/* function to reallocate memory *\/$/;"	m	struct:global_State
func	src/lstate.h	/^  StkId func;  \/* function index in the stack *\/$/;"	m	struct:CallInfo
gcdept	src/lstate.h	/^  lu_mem gcdept;  \/* how much GC is `behind schedule' *\/$/;"	m	struct:global_State
gch	src/lstate.h	/^  GCheader gch;$/;"	m	union:GCObject
gclist	src/lstate.h	/^  GCObject *gclist;$/;"	m	struct:lua_State
gco2cl	src/lstate.h	/^#define gco2cl(/;"	d
gco2h	src/lstate.h	/^#define gco2h(/;"	d
gco2p	src/lstate.h	/^#define gco2p(/;"	d
gco2th	src/lstate.h	/^#define gco2th(/;"	d
gco2ts	src/lstate.h	/^#define gco2ts(/;"	d
gco2u	src/lstate.h	/^#define gco2u(/;"	d
gco2uv	src/lstate.h	/^#define gco2uv(/;"	d
gcpause	src/lstate.h	/^  int gcpause;  \/* size of pause between successive GCs *\/$/;"	m	struct:global_State
gcstate	src/lstate.h	/^  lu_byte gcstate;  \/* state of garbage collector *\/$/;"	m	struct:global_State
gcstepmul	src/lstate.h	/^  int gcstepmul;  \/* GC `granularity' *\/$/;"	m	struct:global_State
global_State	src/lstate.h	/^typedef struct global_State {$/;"	s
global_State	src/lstate.h	/^} global_State;$/;"	t	typeref:struct:global_State
gray	src/lstate.h	/^  GCObject *gray;  \/* list of gray objects *\/$/;"	m	struct:global_State
grayagain	src/lstate.h	/^  GCObject *grayagain;  \/* list of objects to be traversed atomically *\/$/;"	m	struct:global_State
gt	src/lstate.h	/^#define gt(/;"	d
h	src/lstate.h	/^  struct Table h;$/;"	m	union:GCObject	typeref:struct:GCObject::Table
hash	src/lstate.h	/^  GCObject **hash;$/;"	m	struct:stringtable
hook	src/lstate.h	/^  lua_Hook hook;$/;"	m	struct:lua_State
hookcount	src/lstate.h	/^  int hookcount;$/;"	m	struct:lua_State
hookmask	src/lstate.h	/^  lu_byte hookmask;$/;"	m	struct:lua_State
isLua	src/lstate.h	/^#define isLua(/;"	d
l_G	src/lstate.h	/^  global_State *l_G;$/;"	m	struct:lua_State
l_gt	src/lstate.h	/^  TValue l_gt;  \/* table of globals *\/$/;"	m	struct:lua_State
l_registry	src/lstate.h	/^  TValue l_registry;$/;"	m	struct:global_State
lstate_h	src/lstate.h	/^#define lstate_h$/;"	d
lua_State	src/lstate.h	/^struct lua_State {$/;"	s
mainthread	src/lstate.h	/^  struct lua_State *mainthread;$/;"	m	struct:global_State	typeref:struct:global_State::lua_State
mt	src/lstate.h	/^  struct Table *mt[NUM_TAGS];  \/* metatables for basic types *\/$/;"	m	struct:global_State	typeref:struct:global_State::Table
nCcalls	src/lstate.h	/^  unsigned short nCcalls;  \/* number of nested C calls *\/$/;"	m	struct:lua_State
ngcotouv	src/lstate.h	/^#define ngcotouv(/;"	d
nresults	src/lstate.h	/^  int nresults;  \/* expected number of results from this function *\/$/;"	m	struct:CallInfo
nuse	src/lstate.h	/^  lu_int32 nuse;  \/* number of elements *\/$/;"	m	struct:stringtable
obj2gco	src/lstate.h	/^#define obj2gco(/;"	d
openupval	src/lstate.h	/^  GCObject *openupval;  \/* list of open upvalues in this stack *\/$/;"	m	struct:lua_State
p	src/lstate.h	/^  struct Proto p;$/;"	m	union:GCObject	typeref:struct:GCObject::Proto
panic	src/lstate.h	/^  lua_CFunction panic;  \/* to be called in unprotected errors *\/$/;"	m	struct:global_State
rawgco2ts	src/lstate.h	/^#define rawgco2ts(/;"	d
rawgco2u	src/lstate.h	/^#define rawgco2u(/;"	d
registry	src/lstate.h	/^#define registry(/;"	d
rootgc	src/lstate.h	/^  GCObject *rootgc;  \/* list of all collectable objects *\/$/;"	m	struct:global_State
savedpc	src/lstate.h	/^  const Instruction *savedpc;  \/* `savedpc' of current function *\/$/;"	m	struct:lua_State
savedpc	src/lstate.h	/^  const Instruction *savedpc;$/;"	m	struct:CallInfo
size	src/lstate.h	/^  int size;$/;"	m	struct:stringtable
size_ci	src/lstate.h	/^  int size_ci;  \/* size of array `base_ci' *\/$/;"	m	struct:lua_State
stack	src/lstate.h	/^  StkId stack;  \/* stack base *\/$/;"	m	struct:lua_State
stack_last	src/lstate.h	/^  StkId stack_last;  \/* last free slot in the stack *\/$/;"	m	struct:lua_State
stacksize	src/lstate.h	/^  int stacksize;$/;"	m	struct:lua_State
status	src/lstate.h	/^  lu_byte status;$/;"	m	struct:lua_State
stringtable	src/lstate.h	/^typedef struct stringtable {$/;"	s
stringtable	src/lstate.h	/^} stringtable;$/;"	t	typeref:struct:stringtable
strt	src/lstate.h	/^  stringtable strt;  \/* hash table for strings *\/$/;"	m	struct:global_State
sweepgc	src/lstate.h	/^  GCObject **sweepgc;  \/* position of sweep in `rootgc' *\/$/;"	m	struct:global_State
sweepstrgc	src/lstate.h	/^  int sweepstrgc;  \/* position of sweep in `strt' *\/$/;"	m	struct:global_State
tailcalls	src/lstate.h	/^  int tailcalls;  \/* number of tail calls lost under this entry *\/$/;"	m	struct:CallInfo
th	src/lstate.h	/^  struct lua_State th;  \/* thread *\/$/;"	m	union:GCObject	typeref:struct:GCObject::lua_State
tmname	src/lstate.h	/^  TString *tmname[TM_N];  \/* array with tag-method names *\/$/;"	m	struct:global_State
tmudata	src/lstate.h	/^  GCObject *tmudata;  \/* last element of list of userdata to be GC *\/$/;"	m	struct:global_State
top	src/lstate.h	/^  StkId	top;  \/* top for this function *\/$/;"	m	struct:CallInfo
top	src/lstate.h	/^  StkId top;  \/* first free slot in the stack *\/$/;"	m	struct:lua_State
totalbytes	src/lstate.h	/^  lu_mem totalbytes;  \/* number of bytes currently allocated *\/$/;"	m	struct:global_State
ts	src/lstate.h	/^  union TString ts;$/;"	m	union:GCObject	typeref:union:GCObject::TString
u	src/lstate.h	/^  union Udata u;$/;"	m	union:GCObject	typeref:union:GCObject::Udata
ud	src/lstate.h	/^  void *ud;         \/* auxiliary data to `frealloc' *\/$/;"	m	struct:global_State
uv	src/lstate.h	/^  struct UpVal uv;$/;"	m	union:GCObject	typeref:struct:GCObject::UpVal
uvhead	src/lstate.h	/^  UpVal uvhead;  \/* head of double-linked list of all open upvalues *\/$/;"	m	struct:global_State
weak	src/lstate.h	/^  GCObject *weak;  \/* list of weak tables (to be cleared) *\/$/;"	m	struct:global_State
LUA_CORE	src/lstring.c	/^#define LUA_CORE$/;"	d	file:
lstring_c	src/lstring.c	/^#define lstring_c$/;"	d	file:
luaS_newlstr	src/lstring.c	/^TString *luaS_newlstr (lua_State *L, const char *str, size_t l) {$/;"	f
luaS_newudata	src/lstring.c	/^Udata *luaS_newudata (lua_State *L, size_t s, Table *e) {$/;"	f
luaS_resize	src/lstring.c	/^void luaS_resize (lua_State *L, int newsize) {$/;"	f
newlstr	src/lstring.c	/^static TString *newlstr (lua_State *L, const char *str, size_t l,$/;"	f	file:
lstring_h	src/lstring.h	/^#define lstring_h$/;"	d
luaS_fix	src/lstring.h	/^#define luaS_fix(/;"	d
luaS_new	src/lstring.h	/^#define luaS_new(/;"	d
luaS_newliteral	src/lstring.h	/^#define luaS_newliteral(/;"	d
sizestring	src/lstring.h	/^#define sizestring(/;"	d
sizeudata	src/lstring.h	/^#define sizeudata(/;"	d
CAP_POSITION	src/lstrlib.c	/^#define CAP_POSITION	/;"	d	file:
CAP_UNFINISHED	src/lstrlib.c	/^#define CAP_UNFINISHED	/;"	d	file:
FLAGS	src/lstrlib.c	/^#define FLAGS	/;"	d	file:
L	src/lstrlib.c	/^  lua_State *L;$/;"	m	struct:MatchState	file:
LUA_LIB	src/lstrlib.c	/^#define LUA_LIB$/;"	d	file:
L_ESC	src/lstrlib.c	/^#define L_ESC	/;"	d	file:
MAX_FORMAT	src/lstrlib.c	/^#define MAX_FORMAT	/;"	d	file:
MAX_ITEM	src/lstrlib.c	/^#define MAX_ITEM	/;"	d	file:
MatchState	src/lstrlib.c	/^typedef struct MatchState {$/;"	s	file:
MatchState	src/lstrlib.c	/^} MatchState;$/;"	t	typeref:struct:MatchState	file:
SPECIALS	src/lstrlib.c	/^#define SPECIALS	/;"	d	file:
add_s	src/lstrlib.c	/^static void add_s (MatchState *ms, luaL_Buffer *b, const char *s,$/;"	f	file:
add_value	src/lstrlib.c	/^static void add_value (MatchState *ms, luaL_Buffer *b, const char *s,$/;"	f	file:
addintlen	src/lstrlib.c	/^static void addintlen (char *form) {$/;"	f	file:
addquoted	src/lstrlib.c	/^static void addquoted (lua_State *L, luaL_Buffer *b, int arg) {$/;"	f	file:
capture	src/lstrlib.c	/^  } capture[LUA_MAXCAPTURES];$/;"	m	struct:MatchState	typeref:struct:MatchState::__anon14	file:
capture_to_close	src/lstrlib.c	/^static int capture_to_close (MatchState *ms) {$/;"	f	file:
check_capture	src/lstrlib.c	/^static int check_capture (MatchState *ms, int l) {$/;"	f	file:
classend	src/lstrlib.c	/^static const char *classend (MatchState *ms, const char *p) {$/;"	f	file:
createmetatable	src/lstrlib.c	/^static void createmetatable (lua_State *L) {$/;"	f	file:
end_capture	src/lstrlib.c	/^static const char *end_capture (MatchState *ms, const char *s,$/;"	f	file:
gfind_nodef	src/lstrlib.c	/^static int gfind_nodef (lua_State *L) {$/;"	f	file:
gmatch	src/lstrlib.c	/^static int gmatch (lua_State *L) {$/;"	f	file:
gmatch_aux	src/lstrlib.c	/^static int gmatch_aux (lua_State *L) {$/;"	f	file:
init	src/lstrlib.c	/^    const char *init;$/;"	m	struct:MatchState::__anon14	file:
len	src/lstrlib.c	/^    ptrdiff_t len;$/;"	m	struct:MatchState::__anon14	file:
level	src/lstrlib.c	/^  int level;  \/* total number of captures (finished or unfinished) *\/$/;"	m	struct:MatchState	file:
lmemfind	src/lstrlib.c	/^static const char *lmemfind (const char *s1, size_t l1,$/;"	f	file:
lstrlib_c	src/lstrlib.c	/^#define lstrlib_c$/;"	d	file:
luaopen_string	src/lstrlib.c	/^LUALIB_API int luaopen_string (lua_State *L) {$/;"	f
match	src/lstrlib.c	/^static const char *match (MatchState *ms, const char *s, const char *p) {$/;"	f	file:
match_capture	src/lstrlib.c	/^static const char *match_capture (MatchState *ms, const char *s, int l) {$/;"	f	file:
match_class	src/lstrlib.c	/^static int match_class (int c, int cl) {$/;"	f	file:
matchbalance	src/lstrlib.c	/^static const char *matchbalance (MatchState *ms, const char *s,$/;"	f	file:
matchbracketclass	src/lstrlib.c	/^static int matchbracketclass (int c, const char *p, const char *ec) {$/;"	f	file:
max_expand	src/lstrlib.c	/^static const char *max_expand (MatchState *ms, const char *s,$/;"	f	file:
min_expand	src/lstrlib.c	/^static const char *min_expand (MatchState *ms, const char *s,$/;"	f	file:
posrelat	src/lstrlib.c	/^static ptrdiff_t posrelat (ptrdiff_t pos, size_t len) {$/;"	f	file:
push_captures	src/lstrlib.c	/^static int push_captures (MatchState *ms, const char *s, const char *e) {$/;"	f	file:
push_onecapture	src/lstrlib.c	/^static void push_onecapture (MatchState *ms, int i, const char *s,$/;"	f	file:
scanformat	src/lstrlib.c	/^static const char *scanformat (lua_State *L, const char *strfrmt, char *form) {$/;"	f	file:
singlematch	src/lstrlib.c	/^static int singlematch (int c, const char *p, const char *ep) {$/;"	f	file:
src_end	src/lstrlib.c	/^  const char *src_end;  \/* end (`\\0') of source string *\/$/;"	m	struct:MatchState	file:
src_init	src/lstrlib.c	/^  const char *src_init;  \/* init of source string *\/$/;"	m	struct:MatchState	file:
start_capture	src/lstrlib.c	/^static const char *start_capture (MatchState *ms, const char *s,$/;"	f	file:
str_byte	src/lstrlib.c	/^static int str_byte (lua_State *L) {$/;"	f	file:
str_char	src/lstrlib.c	/^static int str_char (lua_State *L) {$/;"	f	file:
str_dump	src/lstrlib.c	/^static int str_dump (lua_State *L) {$/;"	f	file:
str_find	src/lstrlib.c	/^static int str_find (lua_State *L) {$/;"	f	file:
str_find_aux	src/lstrlib.c	/^static int str_find_aux (lua_State *L, int find) {$/;"	f	file:
str_format	src/lstrlib.c	/^static int str_format (lua_State *L) {$/;"	f	file:
str_gsub	src/lstrlib.c	/^static int str_gsub (lua_State *L) {$/;"	f	file:
str_len	src/lstrlib.c	/^static int str_len (lua_State *L) {$/;"	f	file:
str_lower	src/lstrlib.c	/^static int str_lower (lua_State *L) {$/;"	f	file:
str_match	src/lstrlib.c	/^static int str_match (lua_State *L) {$/;"	f	file:
str_rep	src/lstrlib.c	/^static int str_rep (lua_State *L) {$/;"	f	file:
str_reverse	src/lstrlib.c	/^static int str_reverse (lua_State *L) {$/;"	f	file:
str_sub	src/lstrlib.c	/^static int str_sub (lua_State *L) {$/;"	f	file:
str_upper	src/lstrlib.c	/^static int str_upper (lua_State *L) {$/;"	f	file:
strlib	src/lstrlib.c	/^static const luaL_Reg strlib[] = {$/;"	v	file:
uchar	src/lstrlib.c	/^#define uchar(/;"	d	file:
writer	src/lstrlib.c	/^static int writer (lua_State *L, const void* b, size_t size, void* B) {$/;"	f	file:
LUA_CORE	src/ltable.c	/^#define LUA_CORE$/;"	d	file:
MAXASIZE	src/ltable.c	/^#define MAXASIZE	/;"	d	file:
MAXBITS	src/ltable.c	/^#define MAXBITS	/;"	d	file:
arrayindex	src/ltable.c	/^static int arrayindex (const TValue *key) {$/;"	f	file:
computesizes	src/ltable.c	/^static int computesizes (int nums[], int *narray) {$/;"	f	file:
countint	src/ltable.c	/^static int countint (const TValue *key, int *nums) {$/;"	f	file:
dummynode	src/ltable.c	/^#define dummynode	/;"	d	file:
dummynode_	src/ltable.c	/^static const Node dummynode_ = {$/;"	v	file:
findindex	src/ltable.c	/^static int findindex (lua_State *L, Table *t, StkId key) {$/;"	f	file:
getfreepos	src/ltable.c	/^static Node *getfreepos (Table *t) {$/;"	f	file:
hashboolean	src/ltable.c	/^#define hashboolean(/;"	d	file:
hashmod	src/ltable.c	/^#define hashmod(/;"	d	file:
hashnum	src/ltable.c	/^static Node *hashnum (const Table *t, lua_Number n) {$/;"	f	file:
hashpointer	src/ltable.c	/^#define hashpointer(/;"	d	file:
hashpow2	src/ltable.c	/^#define hashpow2(/;"	d	file:
hashstr	src/ltable.c	/^#define hashstr(/;"	d	file:
ltable_c	src/ltable.c	/^#define ltable_c$/;"	d	file:
luaH_free	src/ltable.c	/^void luaH_free (lua_State *L, Table *t) {$/;"	f
luaH_get	src/ltable.c	/^const TValue *luaH_get (Table *t, const TValue *key) {$/;"	f
luaH_getn	src/ltable.c	/^int luaH_getn (Table *t) {$/;"	f
luaH_getnum	src/ltable.c	/^const TValue *luaH_getnum (Table *t, int key) {$/;"	f
luaH_getstr	src/ltable.c	/^const TValue *luaH_getstr (Table *t, TString *key) {$/;"	f
luaH_isdummy	src/ltable.c	/^int luaH_isdummy (Node *n) { return n == dummynode; }$/;"	f
luaH_mainposition	src/ltable.c	/^Node *luaH_mainposition (const Table *t, const TValue *key) {$/;"	f
luaH_new	src/ltable.c	/^Table *luaH_new (lua_State *L, int narray, int nhash) {$/;"	f
luaH_next	src/ltable.c	/^int luaH_next (lua_State *L, Table *t, StkId key) {$/;"	f
luaH_resizearray	src/ltable.c	/^void luaH_resizearray (lua_State *L, Table *t, int nasize) {$/;"	f
luaH_set	src/ltable.c	/^TValue *luaH_set (lua_State *L, Table *t, const TValue *key) {$/;"	f
luaH_setnum	src/ltable.c	/^TValue *luaH_setnum (lua_State *L, Table *t, int key) {$/;"	f
luaH_setstr	src/ltable.c	/^TValue *luaH_setstr (lua_State *L, Table *t, TString *key) {$/;"	f
mainposition	src/ltable.c	/^static Node *mainposition (const Table *t, const TValue *key) {$/;"	f	file:
newkey	src/ltable.c	/^static TValue *newkey (lua_State *L, Table *t, const TValue *key) {$/;"	f	file:
numints	src/ltable.c	/^#define numints	/;"	d	file:
numusearray	src/ltable.c	/^static int numusearray (const Table *t, int *nums) {$/;"	f	file:
numusehash	src/ltable.c	/^static int numusehash (const Table *t, int *nums, int *pnasize) {$/;"	f	file:
rehash	src/ltable.c	/^static void rehash (lua_State *L, Table *t, const TValue *ek) {$/;"	f	file:
resize	src/ltable.c	/^static void resize (lua_State *L, Table *t, int nasize, int nhsize) {$/;"	f	file:
setarrayvector	src/ltable.c	/^static void setarrayvector (lua_State *L, Table *t, int size) {$/;"	f	file:
setnodevector	src/ltable.c	/^static void setnodevector (lua_State *L, Table *t, int size) {$/;"	f	file:
unbound_search	src/ltable.c	/^static int unbound_search (Table *t, unsigned int j) {$/;"	f	file:
gkey	src/ltable.h	/^#define gkey(/;"	d
gnext	src/ltable.h	/^#define gnext(/;"	d
gnode	src/ltable.h	/^#define gnode(/;"	d
gval	src/ltable.h	/^#define gval(/;"	d
key2tval	src/ltable.h	/^#define key2tval(/;"	d
ltable_h	src/ltable.h	/^#define ltable_h$/;"	d
LUA_LIB	src/ltablib.c	/^#define LUA_LIB$/;"	d	file:
addfield	src/ltablib.c	/^static void addfield (lua_State *L, luaL_Buffer *b, int i) {$/;"	f	file:
aux_getn	src/ltablib.c	/^#define aux_getn(/;"	d	file:
auxsort	src/ltablib.c	/^static void auxsort (lua_State *L, int l, int u) {$/;"	f	file:
foreach	src/ltablib.c	/^static int foreach (lua_State *L) {$/;"	f	file:
foreachi	src/ltablib.c	/^static int foreachi (lua_State *L) {$/;"	f	file:
getn	src/ltablib.c	/^static int getn (lua_State *L) {$/;"	f	file:
ltablib_c	src/ltablib.c	/^#define ltablib_c$/;"	d	file:
luaopen_table	src/ltablib.c	/^LUALIB_API int luaopen_table (lua_State *L) {$/;"	f
maxn	src/ltablib.c	/^static int maxn (lua_State *L) {$/;"	f	file:
set2	src/ltablib.c	/^static void set2 (lua_State *L, int i, int j) {$/;"	f	file:
setn	src/ltablib.c	/^static int setn (lua_State *L) {$/;"	f	file:
sort	src/ltablib.c	/^static int sort (lua_State *L) {$/;"	f	file:
sort_comp	src/ltablib.c	/^static int sort_comp (lua_State *L, int a, int b) {$/;"	f	file:
tab_funcs	src/ltablib.c	/^static const luaL_Reg tab_funcs[] = {$/;"	v	file:
tconcat	src/ltablib.c	/^static int tconcat (lua_State *L) {$/;"	f	file:
tinsert	src/ltablib.c	/^static int tinsert (lua_State *L) {$/;"	f	file:
tremove	src/ltablib.c	/^static int tremove (lua_State *L) {$/;"	f	file:
LUA_CORE	src/ltm.c	/^#define LUA_CORE$/;"	d	file:
ltm_c	src/ltm.c	/^#define ltm_c$/;"	d	file:
luaT_gettm	src/ltm.c	/^const TValue *luaT_gettm (Table *events, TMS event, TString *ename) {$/;"	f
luaT_gettmbyobj	src/ltm.c	/^const TValue *luaT_gettmbyobj (lua_State *L, const TValue *o, TMS event) {$/;"	f
luaT_init	src/ltm.c	/^void luaT_init (lua_State *L) {$/;"	f
luaT_typenames	src/ltm.c	/^const char *const luaT_typenames[] = {$/;"	v
TMS	src/ltm.h	/^} TMS;$/;"	t	typeref:enum:__anon15
TM_ADD	src/ltm.h	/^  TM_ADD,$/;"	e	enum:__anon15
TM_CALL	src/ltm.h	/^  TM_CALL,$/;"	e	enum:__anon15
TM_CONCAT	src/ltm.h	/^  TM_CONCAT,$/;"	e	enum:__anon15
TM_DIV	src/ltm.h	/^  TM_DIV,$/;"	e	enum:__anon15
TM_EQ	src/ltm.h	/^  TM_EQ,  \/* last tag method with `fast' access *\/$/;"	e	enum:__anon15
TM_GC	src/ltm.h	/^  TM_GC,$/;"	e	enum:__anon15
TM_INDEX	src/ltm.h	/^  TM_INDEX,$/;"	e	enum:__anon15
TM_LE	src/ltm.h	/^  TM_LE,$/;"	e	enum:__anon15
TM_LEN	src/ltm.h	/^  TM_LEN,$/;"	e	enum:__anon15
TM_LT	src/ltm.h	/^  TM_LT,$/;"	e	enum:__anon15
TM_MOD	src/ltm.h	/^  TM_MOD,$/;"	e	enum:__anon15
TM_MODE	src/ltm.h	/^  TM_MODE,$/;"	e	enum:__anon15
TM_MUL	src/ltm.h	/^  TM_MUL,$/;"	e	enum:__anon15
TM_N	src/ltm.h	/^  TM_N		\/* number of elements in the enum *\/$/;"	e	enum:__anon15
TM_NEWINDEX	src/ltm.h	/^  TM_NEWINDEX,$/;"	e	enum:__anon15
TM_POW	src/ltm.h	/^  TM_POW,$/;"	e	enum:__anon15
TM_SUB	src/ltm.h	/^  TM_SUB,$/;"	e	enum:__anon15
TM_UNM	src/ltm.h	/^  TM_UNM,$/;"	e	enum:__anon15
fasttm	src/ltm.h	/^#define fasttm(/;"	d
gfasttm	src/ltm.h	/^#define gfasttm(/;"	d
ltm_h	src/ltm.h	/^#define ltm_h$/;"	d
luaT_typenames	src/ltm.h	/^LUAI_DATA const char *const luaT_typenames[];$/;"	v
Smain	src/lua.c	/^struct Smain {$/;"	s	file:
argc	src/lua.c	/^  int argc;$/;"	m	struct:Smain	file:
argv	src/lua.c	/^  char **argv;$/;"	m	struct:Smain	file:
collectargs	src/lua.c	/^static int collectargs (char **argv, int *pi, int *pv, int *pe) {$/;"	f	file:
docall	src/lua.c	/^static int docall (lua_State *L, int narg, int clear) {$/;"	f	file:
dofile	src/lua.c	/^static int dofile (lua_State *L, const char *name) {$/;"	f	file:
dolibrary	src/lua.c	/^static int dolibrary (lua_State *L, const char *name) {$/;"	f	file:
dostring	src/lua.c	/^static int dostring (lua_State *L, const char *s, const char *name) {$/;"	f	file:
dotty	src/lua.c	/^static void dotty (lua_State *L) {$/;"	f	file:
get_prompt	src/lua.c	/^static const char *get_prompt (lua_State *L, int firstline) {$/;"	f	file:
getargs	src/lua.c	/^static int getargs (lua_State *L, char **argv, int n) {$/;"	f	file:
globalL	src/lua.c	/^static lua_State *globalL = NULL;$/;"	v	file:
handle_luainit	src/lua.c	/^static int handle_luainit (lua_State *L) {$/;"	f	file:
handle_script	src/lua.c	/^static int handle_script (lua_State *L, char **argv, int n) {$/;"	f	file:
incomplete	src/lua.c	/^static int incomplete (lua_State *L, int status) {$/;"	f	file:
l_message	src/lua.c	/^static void l_message (const char *pname, const char *msg) {$/;"	f	file:
laction	src/lua.c	/^static void laction (int i) {$/;"	f	file:
loadline	src/lua.c	/^static int loadline (lua_State *L) {$/;"	f	file:
lstop	src/lua.c	/^static void lstop (lua_State *L, lua_Debug *ar) {$/;"	f	file:
lua_c	src/lua.c	/^#define lua_c$/;"	d	file:
main	src/lua.c	/^int main (int argc, char **argv) {$/;"	f
notail	src/lua.c	/^#define notail(/;"	d	file:
pmain	src/lua.c	/^static int pmain (lua_State *L) {$/;"	f	file:
print_usage	src/lua.c	/^static void print_usage (void) {$/;"	f	file:
print_version	src/lua.c	/^static void print_version (void) {$/;"	f	file:
progname	src/lua.c	/^static const char *progname = LUA_PROGNAME;$/;"	v	file:
pushline	src/lua.c	/^static int pushline (lua_State *L, int firstline) {$/;"	f	file:
report	src/lua.c	/^static int report (lua_State *L, int status) {$/;"	f	file:
runargs	src/lua.c	/^static int runargs (lua_State *L, char **argv, int n) {$/;"	f	file:
status	src/lua.c	/^  int status;$/;"	m	struct:Smain	file:
traceback	src/lua.c	/^static int traceback (lua_State *L) {$/;"	f	file:
LUA_AUTHORS	src/lua.h	/^#define LUA_AUTHORS /;"	d
LUA_COPYRIGHT	src/lua.h	/^#define LUA_COPYRIGHT	/;"	d
LUA_ENVIRONINDEX	src/lua.h	/^#define LUA_ENVIRONINDEX	/;"	d
LUA_ERRERR	src/lua.h	/^#define LUA_ERRERR	/;"	d
LUA_ERRMEM	src/lua.h	/^#define LUA_ERRMEM	/;"	d
LUA_ERRRUN	src/lua.h	/^#define LUA_ERRRUN	/;"	d
LUA_ERRSYNTAX	src/lua.h	/^#define LUA_ERRSYNTAX	/;"	d
LUA_GCCOLLECT	src/lua.h	/^#define LUA_GCCOLLECT	/;"	d
LUA_GCCOUNT	src/lua.h	/^#define LUA_GCCOUNT	/;"	d
LUA_GCCOUNTB	src/lua.h	/^#define LUA_GCCOUNTB	/;"	d
LUA_GCRESTART	src/lua.h	/^#define LUA_GCRESTART	/;"	d
LUA_GCSETPAUSE	src/lua.h	/^#define LUA_GCSETPAUSE	/;"	d
LUA_GCSETSTEPMUL	src/lua.h	/^#define LUA_GCSETSTEPMUL	/;"	d
LUA_GCSTEP	src/lua.h	/^#define LUA_GCSTEP	/;"	d
LUA_GCSTOP	src/lua.h	/^#define LUA_GCSTOP	/;"	d
LUA_GLOBALSINDEX	src/lua.h	/^#define LUA_GLOBALSINDEX	/;"	d
LUA_HOOKCALL	src/lua.h	/^#define LUA_HOOKCALL	/;"	d
LUA_HOOKCOUNT	src/lua.h	/^#define LUA_HOOKCOUNT	/;"	d
LUA_HOOKLINE	src/lua.h	/^#define LUA_HOOKLINE	/;"	d
LUA_HOOKRET	src/lua.h	/^#define LUA_HOOKRET	/;"	d
LUA_HOOKTAILRET	src/lua.h	/^#define LUA_HOOKTAILRET /;"	d
LUA_MASKCALL	src/lua.h	/^#define LUA_MASKCALL	/;"	d
LUA_MASKCOUNT	src/lua.h	/^#define LUA_MASKCOUNT	/;"	d
LUA_MASKLINE	src/lua.h	/^#define LUA_MASKLINE	/;"	d
LUA_MASKRET	src/lua.h	/^#define LUA_MASKRET	/;"	d
LUA_MINSTACK	src/lua.h	/^#define LUA_MINSTACK	/;"	d
LUA_MULTRET	src/lua.h	/^#define LUA_MULTRET	/;"	d
LUA_REGISTRYINDEX	src/lua.h	/^#define LUA_REGISTRYINDEX	/;"	d
LUA_RELEASE	src/lua.h	/^#define LUA_RELEASE	/;"	d
LUA_SIGNATURE	src/lua.h	/^#define	LUA_SIGNATURE	/;"	d
LUA_TBOOLEAN	src/lua.h	/^#define LUA_TBOOLEAN	/;"	d
LUA_TFUNCTION	src/lua.h	/^#define LUA_TFUNCTION	/;"	d
LUA_TLIGHTUSERDATA	src/lua.h	/^#define LUA_TLIGHTUSERDATA	/;"	d
LUA_TNIL	src/lua.h	/^#define LUA_TNIL	/;"	d
LUA_TNONE	src/lua.h	/^#define LUA_TNONE	/;"	d
LUA_TNUMBER	src/lua.h	/^#define LUA_TNUMBER	/;"	d
LUA_TSTRING	src/lua.h	/^#define LUA_TSTRING	/;"	d
LUA_TTABLE	src/lua.h	/^#define LUA_TTABLE	/;"	d
LUA_TTHREAD	src/lua.h	/^#define LUA_TTHREAD	/;"	d
LUA_TUSERDATA	src/lua.h	/^#define LUA_TUSERDATA	/;"	d
LUA_VERSION	src/lua.h	/^#define LUA_VERSION	/;"	d
LUA_VERSION_NUM	src/lua.h	/^#define LUA_VERSION_NUM	/;"	d
LUA_YIELD	src/lua.h	/^#define LUA_YIELD	/;"	d
currentline	src/lua.h	/^  int currentline;	\/* (l) *\/$/;"	m	struct:lua_Debug
event	src/lua.h	/^  int event;$/;"	m	struct:lua_Debug
i_ci	src/lua.h	/^  int i_ci;  \/* active function *\/$/;"	m	struct:lua_Debug
lastlinedefined	src/lua.h	/^  int lastlinedefined;	\/* (S) *\/$/;"	m	struct:lua_Debug
linedefined	src/lua.h	/^  int linedefined;	\/* (S) *\/$/;"	m	struct:lua_Debug
lua_Alloc	src/lua.h	/^typedef void * (*lua_Alloc) (void *ud, void *ptr, size_t osize, size_t nsize);$/;"	t
lua_CFunction	src/lua.h	/^typedef int (*lua_CFunction) (lua_State *L);$/;"	t
lua_Chunkreader	src/lua.h	/^#define lua_Chunkreader	/;"	d
lua_Chunkwriter	src/lua.h	/^#define lua_Chunkwriter	/;"	d
lua_Debug	src/lua.h	/^struct lua_Debug {$/;"	s
lua_Debug	src/lua.h	/^typedef struct lua_Debug lua_Debug;  \/* activation record *\/$/;"	t	typeref:struct:lua_Debug
lua_Hook	src/lua.h	/^typedef void (*lua_Hook) (lua_State *L, lua_Debug *ar);$/;"	t
lua_Integer	src/lua.h	/^typedef LUA_INTEGER lua_Integer;$/;"	t
lua_Number	src/lua.h	/^typedef LUA_NUMBER lua_Number;$/;"	t
lua_Reader	src/lua.h	/^typedef const char * (*lua_Reader) (lua_State *L, void *ud, size_t *sz);$/;"	t
lua_State	src/lua.h	/^typedef struct lua_State lua_State;$/;"	t	typeref:struct:lua_State
lua_Writer	src/lua.h	/^typedef int (*lua_Writer) (lua_State *L, const void* p, size_t sz, void* ud);$/;"	t
lua_getgccount	src/lua.h	/^#define lua_getgccount(/;"	d
lua_getglobal	src/lua.h	/^#define lua_getglobal(/;"	d
lua_getregistry	src/lua.h	/^#define lua_getregistry(/;"	d
lua_h	src/lua.h	/^#define lua_h$/;"	d
lua_isboolean	src/lua.h	/^#define lua_isboolean(/;"	d
lua_isfunction	src/lua.h	/^#define lua_isfunction(/;"	d
lua_islightuserdata	src/lua.h	/^#define lua_islightuserdata(/;"	d
lua_isnil	src/lua.h	/^#define lua_isnil(/;"	d
lua_isnone	src/lua.h	/^#define lua_isnone(/;"	d
lua_isnoneornil	src/lua.h	/^#define lua_isnoneornil(/;"	d
lua_istable	src/lua.h	/^#define lua_istable(/;"	d
lua_isthread	src/lua.h	/^#define lua_isthread(/;"	d
lua_newtable	src/lua.h	/^#define lua_newtable(/;"	d
lua_open	src/lua.h	/^#define lua_open(/;"	d
lua_pop	src/lua.h	/^#define lua_pop(/;"	d
lua_pushcfunction	src/lua.h	/^#define lua_pushcfunction(/;"	d
lua_pushliteral	src/lua.h	/^#define lua_pushliteral(/;"	d
lua_register	src/lua.h	/^#define lua_register(/;"	d
lua_setglobal	src/lua.h	/^#define lua_setglobal(/;"	d
lua_strlen	src/lua.h	/^#define lua_strlen(/;"	d
lua_tostring	src/lua.h	/^#define lua_tostring(/;"	d
lua_upvalueindex	src/lua.h	/^#define lua_upvalueindex(/;"	d
name	src/lua.h	/^  const char *name;	\/* (n) *\/$/;"	m	struct:lua_Debug
namewhat	src/lua.h	/^  const char *namewhat;	\/* (n) `global', `local', `field', `method' *\/$/;"	m	struct:lua_Debug
nups	src/lua.h	/^  int nups;		\/* (u) number of upvalues *\/$/;"	m	struct:lua_Debug
short_src	src/lua.h	/^  char short_src[LUA_IDSIZE]; \/* (S) *\/$/;"	m	struct:lua_Debug
source	src/lua.h	/^  const char *source;	\/* (S) *\/$/;"	m	struct:lua_Debug
what	src/lua.h	/^  const char *what;	\/* (S) `Lua', `C', `main', `tail' *\/$/;"	m	struct:lua_Debug
IS	src/luac.c	/^#define	IS(/;"	d	file:
LUA_CORE	src/luac.c	/^#define LUA_CORE$/;"	d	file:
OUTPUT	src/luac.c	/^#define	OUTPUT	/;"	d	file:
Output	src/luac.c	/^static char Output[]={ OUTPUT };	\/* default output file name *\/$/;"	v	file:
PROGNAME	src/luac.c	/^#define PROGNAME	/;"	d	file:
Smain	src/luac.c	/^struct Smain {$/;"	s	file:
argc	src/luac.c	/^ int argc;$/;"	m	struct:Smain	file:
argv	src/luac.c	/^ char** argv;$/;"	m	struct:Smain	file:
cannot	src/luac.c	/^static void cannot(const char* what)$/;"	f	file:
combine	src/luac.c	/^static const Proto* combine(lua_State* L, int n)$/;"	f	file:
doargs	src/luac.c	/^static int doargs(int argc, char* argv[])$/;"	f	file:
dumping	src/luac.c	/^static int dumping=1;			\/* dump bytecodes? *\/$/;"	v	file:
fatal	src/luac.c	/^static void fatal(const char* message)$/;"	f	file:
listing	src/luac.c	/^static int listing=0;			\/* list bytecodes? *\/$/;"	v	file:
luac_c	src/luac.c	/^#define luac_c$/;"	d	file:
main	src/luac.c	/^int main(int argc, char* argv[])$/;"	f
output	src/luac.c	/^static const char* output=Output;	\/* actual output file name *\/$/;"	v	file:
pmain	src/luac.c	/^static int pmain(lua_State* L)$/;"	f	file:
progname	src/luac.c	/^static const char* progname=PROGNAME;	\/* actual program name *\/$/;"	v	file:
stripping	src/luac.c	/^static int stripping=0;			\/* strip debug information? *\/$/;"	v	file:
toproto	src/luac.c	/^#define toproto(/;"	d	file:
usage	src/luac.c	/^static void usage(const char* message)$/;"	f	file:
writer	src/luac.c	/^static int writer(lua_State* L, const void* p, size_t size, void* u)$/;"	f	file:
LUAI_BITSINT	src/luaconf.h	/^#define LUAI_BITSINT	/;"	d
LUAI_DATA	src/luaconf.h	/^#define LUAI_DATA	/;"	d
LUAI_EXTRASPACE	src/luaconf.h	/^#define LUAI_EXTRASPACE	/;"	d
LUAI_FUNC	src/luaconf.h	/^#define LUAI_FUNC	/;"	d
LUAI_GCMUL	src/luaconf.h	/^#define LUAI_GCMUL	/;"	d
LUAI_GCPAUSE	src/luaconf.h	/^#define LUAI_GCPAUSE	/;"	d
LUAI_INT32	src/luaconf.h	/^#define LUAI_INT32	/;"	d
LUAI_MAXCALLS	src/luaconf.h	/^#define LUAI_MAXCALLS	/;"	d
LUAI_MAXCCALLS	src/luaconf.h	/^#define LUAI_MAXCCALLS	/;"	d
LUAI_MAXCSTACK	src/luaconf.h	/^#define LUAI_MAXCSTACK	/;"	d
LUAI_MAXINT32	src/luaconf.h	/^#define LUAI_MAXINT32	/;"	d
LUAI_MAXNUMBER2STR	src/luaconf.h	/^#define LUAI_MAXNUMBER2STR	/;"	d
LUAI_MAXUPVALUES	src/luaconf.h	/^#define LUAI_MAXUPVALUES	/;"	d
LUAI_MAXVARS	src/luaconf.h	/^#define LUAI_MAXVARS	/;"	d
LUAI_MEM	src/luaconf.h	/^#define LUAI_MEM	/;"	d
LUAI_THROW	src/luaconf.h	/^#define LUAI_THROW(/;"	d
LUAI_TRY	src/luaconf.h	/^#define LUAI_TRY(/;"	d
LUAI_UACNUMBER	src/luaconf.h	/^#define LUAI_UACNUMBER	/;"	d
LUAI_UINT32	src/luaconf.h	/^#define LUAI_UINT32	/;"	d
LUAI_UMEM	src/luaconf.h	/^#define LUAI_UMEM	/;"	d
LUAI_USER_ALIGNMENT_T	src/luaconf.h	/^#define LUAI_USER_ALIGNMENT_T	/;"	d
LUALIB_API	src/luaconf.h	/^#define LUALIB_API	/;"	d
LUAL_BUFFERSIZE	src/luaconf.h	/^#define LUAL_BUFFERSIZE	/;"	d
LUA_ANSI	src/luaconf.h	/^#define LUA_ANSI$/;"	d
LUA_API	src/luaconf.h	/^#define LUA_API	/;"	d
LUA_API	src/luaconf.h	/^#define LUA_API /;"	d
LUA_CDIR	src/luaconf.h	/^#define LUA_CDIR	/;"	d
LUA_COMPAT_GETN	src/luaconf.h	/^#undef LUA_COMPAT_GETN$/;"	d
LUA_COMPAT_GFIND	src/luaconf.h	/^#define LUA_COMPAT_GFIND$/;"	d
LUA_COMPAT_LOADLIB	src/luaconf.h	/^#undef LUA_COMPAT_LOADLIB$/;"	d
LUA_COMPAT_LSTR	src/luaconf.h	/^#define LUA_COMPAT_LSTR	/;"	d
LUA_COMPAT_MOD	src/luaconf.h	/^#define LUA_COMPAT_MOD$/;"	d
LUA_COMPAT_OPENLIB	src/luaconf.h	/^#define LUA_COMPAT_OPENLIB$/;"	d
LUA_COMPAT_VARARG	src/luaconf.h	/^#define LUA_COMPAT_VARARG$/;"	d
LUA_CPATH	src/luaconf.h	/^#define LUA_CPATH /;"	d
LUA_CPATH_DEFAULT	src/luaconf.h	/^#define LUA_CPATH_DEFAULT /;"	d
LUA_DIRSEP	src/luaconf.h	/^#define LUA_DIRSEP	/;"	d
LUA_DL_DLL	src/luaconf.h	/^#define LUA_DL_DLL$/;"	d
LUA_DL_DLOPEN	src/luaconf.h	/^#define LUA_DL_DLOPEN$/;"	d
LUA_DL_DYLD	src/luaconf.h	/^#define LUA_DL_DYLD	/;"	d
LUA_EXECDIR	src/luaconf.h	/^#define LUA_EXECDIR	/;"	d
LUA_IDSIZE	src/luaconf.h	/^#define LUA_IDSIZE	/;"	d
LUA_IGMARK	src/luaconf.h	/^#define LUA_IGMARK	/;"	d
LUA_INIT	src/luaconf.h	/^#define LUA_INIT	/;"	d
LUA_INTEGER	src/luaconf.h	/^#define LUA_INTEGER	/;"	d
LUA_INTFRMLEN	src/luaconf.h	/^#define LUA_INTFRMLEN	/;"	d
LUA_INTFRM_T	src/luaconf.h	/^#define LUA_INTFRM_T	/;"	d
LUA_LDIR	src/luaconf.h	/^#define LUA_LDIR	/;"	d
LUA_MAXCAPTURES	src/luaconf.h	/^#define LUA_MAXCAPTURES	/;"	d
LUA_MAXINPUT	src/luaconf.h	/^#define LUA_MAXINPUT	/;"	d
LUA_NUMBER	src/luaconf.h	/^#define LUA_NUMBER	/;"	d
LUA_NUMBER_DOUBLE	src/luaconf.h	/^#define LUA_NUMBER_DOUBLE$/;"	d
LUA_NUMBER_FMT	src/luaconf.h	/^#define LUA_NUMBER_FMT	/;"	d
LUA_NUMBER_SCAN	src/luaconf.h	/^#define LUA_NUMBER_SCAN	/;"	d
LUA_PATH	src/luaconf.h	/^#define LUA_PATH /;"	d
LUA_PATHSEP	src/luaconf.h	/^#define LUA_PATHSEP	/;"	d
LUA_PATH_DEFAULT	src/luaconf.h	/^#define LUA_PATH_DEFAULT /;"	d
LUA_PATH_MARK	src/luaconf.h	/^#define LUA_PATH_MARK	/;"	d
LUA_PROGNAME	src/luaconf.h	/^#define LUA_PROGNAME	/;"	d
LUA_PROMPT	src/luaconf.h	/^#define LUA_PROMPT	/;"	d
LUA_PROMPT2	src/luaconf.h	/^#define LUA_PROMPT2	/;"	d
LUA_QL	src/luaconf.h	/^#define LUA_QL(/;"	d
LUA_QS	src/luaconf.h	/^#define LUA_QS	/;"	d
LUA_ROOT	src/luaconf.h	/^#define LUA_ROOT	/;"	d
LUA_TMPNAMBUFSIZE	src/luaconf.h	/^#define LUA_TMPNAMBUFSIZE	/;"	d
LUA_USE_DLOPEN	src/luaconf.h	/^#define LUA_USE_DLOPEN	/;"	d
LUA_USE_ISATTY	src/luaconf.h	/^#define LUA_USE_ISATTY$/;"	d
LUA_USE_MKSTEMP	src/luaconf.h	/^#define LUA_USE_MKSTEMP$/;"	d
LUA_USE_POPEN	src/luaconf.h	/^#define LUA_USE_POPEN$/;"	d
LUA_USE_POSIX	src/luaconf.h	/^#define LUA_USE_POSIX$/;"	d
LUA_USE_READLINE	src/luaconf.h	/^#define LUA_USE_READLINE	/;"	d
LUA_USE_ULONGJMP	src/luaconf.h	/^#define LUA_USE_ULONGJMP$/;"	d
LUA_WIN	src/luaconf.h	/^#define LUA_WIN$/;"	d
l_d	src/luaconf.h	/^union luai_Cast { double l_d; long l_l; };$/;"	m	union:luai_Cast
l_l	src/luaconf.h	/^union luai_Cast { double l_d; long l_l; };$/;"	m	union:luai_Cast
lconfig_h	src/luaconf.h	/^#define lconfig_h$/;"	d
lua_freeline	src/luaconf.h	/^#define lua_freeline(/;"	d
lua_number2int	src/luaconf.h	/^#define lua_number2int(/;"	d
lua_number2integer	src/luaconf.h	/^#define lua_number2integer(/;"	d
lua_number2str	src/luaconf.h	/^#define lua_number2str(/;"	d
lua_pclose	src/luaconf.h	/^#define lua_pclose(/;"	d
lua_popen	src/luaconf.h	/^#define lua_popen(/;"	d
lua_readline	src/luaconf.h	/^#define lua_readline(/;"	d
lua_saveline	src/luaconf.h	/^#define lua_saveline(/;"	d
lua_stdin_is_tty	src/luaconf.h	/^#define lua_stdin_is_tty(/;"	d
lua_str2number	src/luaconf.h	/^#define lua_str2number(/;"	d
lua_tmpnam	src/luaconf.h	/^#define lua_tmpnam(/;"	d
luai_Cast	src/luaconf.h	/^union luai_Cast { double l_d; long l_l; };$/;"	u
luai_apicheck	src/luaconf.h	/^#define luai_apicheck(/;"	d
luai_jmpbuf	src/luaconf.h	/^#define luai_jmpbuf	/;"	d
luai_numadd	src/luaconf.h	/^#define luai_numadd(/;"	d
luai_numdiv	src/luaconf.h	/^#define luai_numdiv(/;"	d
luai_numeq	src/luaconf.h	/^#define luai_numeq(/;"	d
luai_numisnan	src/luaconf.h	/^#define luai_numisnan(/;"	d
luai_numle	src/luaconf.h	/^#define luai_numle(/;"	d
luai_numlt	src/luaconf.h	/^#define luai_numlt(/;"	d
luai_nummod	src/luaconf.h	/^#define luai_nummod(/;"	d
luai_nummul	src/luaconf.h	/^#define luai_nummul(/;"	d
luai_numpow	src/luaconf.h	/^#define luai_numpow(/;"	d
luai_numsub	src/luaconf.h	/^#define luai_numsub(/;"	d
luai_numunm	src/luaconf.h	/^#define luai_numunm(/;"	d
luai_userstateclose	src/luaconf.h	/^#define luai_userstateclose(/;"	d
luai_userstatefree	src/luaconf.h	/^#define luai_userstatefree(/;"	d
luai_userstateopen	src/luaconf.h	/^#define luai_userstateopen(/;"	d
luai_userstateresume	src/luaconf.h	/^#define luai_userstateresume(/;"	d
luai_userstatethread	src/luaconf.h	/^#define luai_userstatethread(/;"	d
luai_userstateyield	src/luaconf.h	/^#define luai_userstateyield(/;"	d
LUA_COLIBNAME	src/lualib.h	/^#define LUA_COLIBNAME	/;"	d
LUA_DBLIBNAME	src/lualib.h	/^#define LUA_DBLIBNAME	/;"	d
LUA_FILEHANDLE	src/lualib.h	/^#define LUA_FILEHANDLE	/;"	d
LUA_IOLIBNAME	src/lualib.h	/^#define LUA_IOLIBNAME	/;"	d
LUA_LOADLIBNAME	src/lualib.h	/^#define LUA_LOADLIBNAME	/;"	d
LUA_MATHLIBNAME	src/lualib.h	/^#define LUA_MATHLIBNAME	/;"	d
LUA_OSLIBNAME	src/lualib.h	/^#define LUA_OSLIBNAME	/;"	d
LUA_STRLIBNAME	src/lualib.h	/^#define LUA_STRLIBNAME	/;"	d
LUA_TABLIBNAME	src/lualib.h	/^#define LUA_TABLIBNAME	/;"	d
lua_assert	src/lualib.h	/^#define lua_assert(/;"	d
lualib_h	src/lualib.h	/^#define lualib_h$/;"	d
IF	src/lundump.c	/^#define IF(/;"	d	file:
L	src/lundump.c	/^ lua_State* L;$/;"	m	struct:__anon16	file:
LUA_CORE	src/lundump.c	/^#define LUA_CORE$/;"	d	file:
LoadBlock	src/lundump.c	/^static void LoadBlock(LoadState* S, void* b, size_t size)$/;"	f	file:
LoadByte	src/lundump.c	/^#define	LoadByte(/;"	d	file:
LoadChar	src/lundump.c	/^static int LoadChar(LoadState* S)$/;"	f	file:
LoadCode	src/lundump.c	/^static void LoadCode(LoadState* S, Proto* f)$/;"	f	file:
LoadConstants	src/lundump.c	/^static void LoadConstants(LoadState* S, Proto* f)$/;"	f	file:
LoadDebug	src/lundump.c	/^static void LoadDebug(LoadState* S, Proto* f)$/;"	f	file:
LoadFunction	src/lundump.c	/^static Proto* LoadFunction(LoadState* S, TString* p)$/;"	f	file:
LoadHeader	src/lundump.c	/^static void LoadHeader(LoadState* S)$/;"	f	file:
LoadInt	src/lundump.c	/^static int LoadInt(LoadState* S)$/;"	f	file:
LoadMem	src/lundump.c	/^#define LoadMem(/;"	d	file:
LoadNumber	src/lundump.c	/^static lua_Number LoadNumber(LoadState* S)$/;"	f	file:
LoadState	src/lundump.c	/^} LoadState;$/;"	t	typeref:struct:__anon16	file:
LoadString	src/lundump.c	/^static TString* LoadString(LoadState* S)$/;"	f	file:
LoadVar	src/lundump.c	/^#define LoadVar(/;"	d	file:
LoadVector	src/lundump.c	/^#define LoadVector(/;"	d	file:
Z	src/lundump.c	/^ ZIO* Z;$/;"	m	struct:__anon16	file:
b	src/lundump.c	/^ Mbuffer* b;$/;"	m	struct:__anon16	file:
error	src/lundump.c	/^#define error(/;"	d	file:
error	src/lundump.c	/^static void error(LoadState* S, const char* why)$/;"	f	file:
luaU_header	src/lundump.c	/^void luaU_header (char* h)$/;"	f
luaU_undump	src/lundump.c	/^Proto* luaU_undump (lua_State* L, ZIO* Z, Mbuffer* buff, const char* name)$/;"	f
lundump_c	src/lundump.c	/^#define lundump_c$/;"	d	file:
name	src/lundump.c	/^ const char* name;$/;"	m	struct:__anon16	file:
LUAC_FORMAT	src/lundump.h	/^#define LUAC_FORMAT	/;"	d
LUAC_HEADERSIZE	src/lundump.h	/^#define LUAC_HEADERSIZE	/;"	d
LUAC_VERSION	src/lundump.h	/^#define LUAC_VERSION	/;"	d
lundump_h	src/lundump.h	/^#define lundump_h$/;"	d
Arith	src/lvm.c	/^static void Arith (lua_State *L, StkId ra, const TValue *rb,$/;"	f	file:
KBx	src/lvm.c	/^#define KBx(/;"	d	file:
LUA_CORE	src/lvm.c	/^#define LUA_CORE$/;"	d	file:
MAXTAGLOOP	src/lvm.c	/^#define MAXTAGLOOP	/;"	d	file:
Protect	src/lvm.c	/^#define Protect(/;"	d	file:
RA	src/lvm.c	/^#define RA(/;"	d	file:
RB	src/lvm.c	/^#define RB(/;"	d	file:
RC	src/lvm.c	/^#define RC(/;"	d	file:
RKB	src/lvm.c	/^#define RKB(/;"	d	file:
RKC	src/lvm.c	/^#define RKC(/;"	d	file:
arith_op	src/lvm.c	/^#define arith_op(/;"	d	file:
callTM	src/lvm.c	/^static void callTM (lua_State *L, const TValue *f, const TValue *p1,$/;"	f	file:
callTMres	src/lvm.c	/^static void callTMres (lua_State *L, StkId res, const TValue *f,$/;"	f	file:
call_binTM	src/lvm.c	/^static int call_binTM (lua_State *L, const TValue *p1, const TValue *p2,$/;"	f	file:
call_orderTM	src/lvm.c	/^static int call_orderTM (lua_State *L, const TValue *p1, const TValue *p2,$/;"	f	file:
dojump	src/lvm.c	/^#define dojump(/;"	d	file:
get_compTM	src/lvm.c	/^static const TValue *get_compTM (lua_State *L, Table *mt1, Table *mt2,$/;"	f	file:
l_strcmp	src/lvm.c	/^static int l_strcmp (const TString *ls, const TString *rs) {$/;"	f	file:
lessequal	src/lvm.c	/^static int lessequal (lua_State *L, const TValue *l, const TValue *r) {$/;"	f	file:
luaV_concat	src/lvm.c	/^void luaV_concat (lua_State *L, int total, int last) {$/;"	f
luaV_equalval	src/lvm.c	/^int luaV_equalval (lua_State *L, const TValue *t1, const TValue *t2) {$/;"	f
luaV_execute	src/lvm.c	/^void luaV_execute (lua_State *L, int nexeccalls) {$/;"	f
luaV_gettable	src/lvm.c	/^void luaV_gettable (lua_State *L, const TValue *t, TValue *key, StkId val) {$/;"	f
luaV_lessthan	src/lvm.c	/^int luaV_lessthan (lua_State *L, const TValue *l, const TValue *r) {$/;"	f
luaV_settable	src/lvm.c	/^void luaV_settable (lua_State *L, const TValue *t, TValue *key, StkId val) {$/;"	f
luaV_tonumber	src/lvm.c	/^const TValue *luaV_tonumber (const TValue *obj, TValue *n) {$/;"	f
luaV_tostring	src/lvm.c	/^int luaV_tostring (lua_State *L, StkId obj) {$/;"	f
lvm_c	src/lvm.c	/^#define lvm_c$/;"	d	file:
runtime_check	src/lvm.c	/^#define runtime_check(/;"	d	file:
traceexec	src/lvm.c	/^static void traceexec (lua_State *L, const Instruction *pc) {$/;"	f	file:
equalobj	src/lvm.h	/^#define equalobj(/;"	d
lvm_h	src/lvm.h	/^#define lvm_h$/;"	d
tonumber	src/lvm.h	/^#define tonumber(/;"	d
tostring	src/lvm.h	/^#define tostring(/;"	d
LUA_CORE	src/lzio.c	/^#define LUA_CORE$/;"	d	file:
luaZ_fill	src/lzio.c	/^int luaZ_fill (ZIO *z) {$/;"	f
luaZ_init	src/lzio.c	/^void luaZ_init (lua_State *L, ZIO *z, lua_Reader reader, void *data) {$/;"	f
luaZ_lookahead	src/lzio.c	/^int luaZ_lookahead (ZIO *z) {$/;"	f
luaZ_openspace	src/lzio.c	/^char *luaZ_openspace (lua_State *L, Mbuffer *buff, size_t n) {$/;"	f
luaZ_read	src/lzio.c	/^size_t luaZ_read (ZIO *z, void *b, size_t n) {$/;"	f
lzio_c	src/lzio.c	/^#define lzio_c$/;"	d	file:
EOZ	src/lzio.h	/^#define EOZ	/;"	d
L	src/lzio.h	/^  lua_State *L;			\/* Lua state (for reader) *\/$/;"	m	struct:Zio
Mbuffer	src/lzio.h	/^typedef struct Mbuffer {$/;"	s
Mbuffer	src/lzio.h	/^} Mbuffer;$/;"	t	typeref:struct:Mbuffer
ZIO	src/lzio.h	/^typedef struct Zio ZIO;$/;"	t	typeref:struct:Zio
Zio	src/lzio.h	/^struct Zio {$/;"	s
buffer	src/lzio.h	/^  char *buffer;$/;"	m	struct:Mbuffer
buffsize	src/lzio.h	/^  size_t buffsize;$/;"	m	struct:Mbuffer
char2int	src/lzio.h	/^#define char2int(/;"	d
data	src/lzio.h	/^  void* data;			\/* additional data *\/$/;"	m	struct:Zio
luaZ_buffer	src/lzio.h	/^#define luaZ_buffer(/;"	d
luaZ_bufflen	src/lzio.h	/^#define luaZ_bufflen(/;"	d
luaZ_freebuffer	src/lzio.h	/^#define luaZ_freebuffer(/;"	d
luaZ_initbuffer	src/lzio.h	/^#define luaZ_initbuffer(/;"	d
luaZ_resetbuffer	src/lzio.h	/^#define luaZ_resetbuffer(/;"	d
luaZ_resizebuffer	src/lzio.h	/^#define luaZ_resizebuffer(/;"	d
luaZ_sizebuffer	src/lzio.h	/^#define luaZ_sizebuffer(/;"	d
lzio_h	src/lzio.h	/^#define lzio_h$/;"	d
n	src/lzio.h	/^  size_t n;			\/* bytes still unread *\/$/;"	m	struct:Zio
n	src/lzio.h	/^  size_t n;$/;"	m	struct:Mbuffer
p	src/lzio.h	/^  const char *p;		\/* current position in buffer *\/$/;"	m	struct:Zio
reader	src/lzio.h	/^  lua_Reader reader;$/;"	m	struct:Zio
zgetc	src/lzio.h	/^#define zgetc(/;"	d
LUA_CORE	src/print.c	/^#define LUA_CORE$/;"	d	file:
PrintCode	src/print.c	/^static void PrintCode(const Proto* f)$/;"	f	file:
PrintConstant	src/print.c	/^static void PrintConstant(const Proto* f, int i)$/;"	f	file:
PrintConstants	src/print.c	/^static void PrintConstants(const Proto* f)$/;"	f	file:
PrintFunction	src/print.c	/^#define PrintFunction	/;"	d	file:
PrintFunction	src/print.c	/^void PrintFunction(const Proto* f, int full)$/;"	f
PrintHeader	src/print.c	/^static void PrintHeader(const Proto* f)$/;"	f	file:
PrintLocals	src/print.c	/^static void PrintLocals(const Proto* f)$/;"	f	file:
PrintString	src/print.c	/^static void PrintString(const TString* ts)$/;"	f	file:
PrintUpvalues	src/print.c	/^static void PrintUpvalues(const Proto* f)$/;"	f	file:
S	src/print.c	/^#define S(/;"	d	file:
SS	src/print.c	/^#define SS(/;"	d	file:
Sizeof	src/print.c	/^#define Sizeof(/;"	d	file:
VOID	src/print.c	/^#define VOID(/;"	d	file:
luac_c	src/print.c	/^#define luac_c$/;"	d	file:
bisect	test/bisect.lua	/^function bisect(f,a,b,fa,fb)$/;"	f
f	test/bisect.lua	/^function f(x)$/;"	f
solve	test/bisect.lua	/^function solve(f,a,b)$/;"	f
local f	test/env.lua	/^local f=function (t,i) return os.getenv(i) end$/;"	f
F 	test/factorial.lua	/^F = function (f)$/;"	f
Y 	test/factorial.lua	/^Y = function (g)$/;"	f
local a 	test/factorial.lua	/^      local a = function (f) return f(f) end$/;"	f
test	test/factorial.lua	/^function test(x)$/;"	f
cache	test/fib.lua	/^function cache(f)$/;"	f
fib	test/fib.lua	/^function fib(n)$/;"	f
test	test/fib.lua	/^function test(s,f)$/;"	f
generatefib 	test/fibfor.lua	/^function generatefib (n)$/;"	f
ARRAY2D	test/life.lua	/^function ARRAY2D(w,h)$/;"	f
CELLS	test/life.lua	/^function CELLS(w,h)$/;"	f
LIFE	test/life.lua	/^function LIFE(w,h)$/;"	f
_CELLS:draw	test/life.lua	/^function _CELLS:draw()$/;"	f
_CELLS:evolve	test/life.lua	/^function _CELLS:evolve(next)$/;"	f
_CELLS:spawn	test/life.lua	/^function _CELLS:spawn(shape,left,top)$/;"	f
delay	test/life.lua	/^function delay() -- NOTE: SYSTEM-DEPENDENT, adjust as necessary$/;"	f
printf	test/printf.lua	/^function printf(...)$/;"	f
local f	test/readonly.lua	/^local f=function (t,i) error("cannot redefine global variable `"..i.."'",2) end$/;"	f
filter 	test/sieve.lua	/^function filter (p, g)$/;"	f
gen 	test/sieve.lua	/^function gen (n)$/;"	f
qsort	test/sort.lua	/^function qsort(x,l,u,f)$/;"	f
selectionsort	test/sort.lua	/^function selectionsort(x,n,f)$/;"	f
show	test/sort.lua	/^function show(m,x)$/;"	f
testsorts	test/sort.lua	/^function testsorts(x)$/;"	f
hook	test/trace-calls.lua	/^local function hook(event)$/;"	f
local log	test/trace-globals.lua	/^ local log=function (name,old,new)$/;"	f
local set	test/trace-globals.lua	/^ local set=function (t,name,value)$/;"	f
local tostring	test/trace-globals.lua	/^ local tostring=function(a)$/;"	f
